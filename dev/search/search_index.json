{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pantsagon","text":"<p>Pantsagon bootstraps hexagonal monorepos managed by Pants, with enforcement from day one.</p> <p>You use Pantsagon to generate a repository where:</p> <ul> <li>each service is structured as <code>domain/</code>, <code>application/</code>, <code>adapters/</code>, <code>entrypoints/</code></li> <li>shared code is split into foundation (pure) and shared adapters (allowlisted integrations)</li> <li>dependency boundaries hard-fail locally and in CI</li> <li>optional packs add contract-first OpenAPI and Docker packaging</li> </ul>"},{"location":"#what-you-can-do-in-v1","title":"What you can do in v1","text":"<ul> <li><code>pantsagon init</code> - create a new monorepo</li> <li><code>pantsagon add service</code> - add a new service skeleton</li> <li><code>pantsagon validate</code> - validate invariants and optionally run Pants checks</li> </ul>"},{"location":"#key-concepts","title":"Key concepts","text":"<ul> <li>Packs: versioned templates (<code>pack.yaml</code> + <code>copier.yml</code> + <code>templates/</code>)</li> <li>Repo lock: <code>.pantsagon.toml</code> is the single source of truth for pack pins and answers</li> <li>Diagnostics: structured errors/warnings emitted by all frontends</li> </ul> <p>Start with Getting started -&gt; Quickstart.</p> <p>Looking to contribute? See Contributing -&gt; Docs.</p>"},{"location":"cli/","title":"CLI overview","text":"<p>v1 commands:</p> <ul> <li><code>pantsagon init</code></li> <li><code>pantsagon add service</code></li> <li><code>pantsagon validate</code></li> </ul> <p>All commands support structured diagnostics and stable exit codes.</p>"},{"location":"cli/add-service/","title":"pantsagon add service","text":"<p>Add a new service skeleton into an existing Pantsagon repo.</p> <pre><code>pantsagon add service &lt;name&gt; --lang python\n</code></pre> <p>Optional:</p> <ul> <li><code>--feature openapi</code></li> <li><code>--feature docker</code></li> <li><code>--strict</code></li> </ul>"},{"location":"cli/exit-codes/","title":"Exit codes","text":"<p>Stable exit codes:</p> <ul> <li><code>0</code> success</li> <li><code>2</code> validation failure (schema/invariants/compatibility)</li> <li><code>3</code> execution failure (IO/renderer/subprocess)</li> <li><code>4</code> internal error (unexpected exception)</li> </ul>"},{"location":"cli/init/","title":"pantsagon init","text":"<p>Create a new monorepo.</p> <pre><code>pantsagon init &lt;repo&gt;\n</code></pre> <p>Common flags:</p> <ul> <li><code>--lang python</code> (required in v1)</li> <li><code>--services a,b</code></li> <li><code>--feature openapi</code> (repeatable)</li> <li><code>--feature docker</code> (repeatable)</li> <li><code>--strict</code></li> <li><code>--renderer copier</code></li> <li><code>--non-interactive</code></li> </ul>"},{"location":"cli/validate/","title":"pantsagon validate","text":"<p>Validate <code>.pantsagon.toml</code>, packs, and repo invariants.</p> <pre><code>pantsagon validate\n</code></pre> <p>Flags:</p> <ul> <li><code>--exec</code> runs configured Pants goals (lint/check/test etc.)</li> <li><code>--strict</code> upgrades warnings to errors</li> <li><code>--json</code> outputs machine-readable Result</li> </ul>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>Pantsagon itself is hexagonal:</p> <ul> <li>Domain models <code>Blueprint -&gt; PackSelection -&gt; RenderPlan -&gt; RepoLock -&gt; Diagnostics</code></li> <li>Application orchestrates <code>init</code>, <code>add service</code>, and <code>validate</code></li> <li>Ports define pack discovery, rendering, workspace IO, policy checks, and command execution</li> <li>Adapters implement those ports (Copier renderer, filesystem workspace, bundled/local packs)</li> </ul> <p>This lets Pantsagon support multiple frontends and third-party extensions without forking.</p>"},{"location":"concepts/diagnostics/","title":"Diagnostics","text":"<p>All frontends emit structured diagnostics:</p> <ul> <li>code (stable identifier)</li> <li>rule (stable rule id / namespace)</li> <li>severity (error|warn|info)</li> <li>message</li> <li>optional location/hint/details</li> </ul> <p>Commands return a Result:</p> <ul> <li>diagnostics</li> <li>artifacts (written paths, applied packs, executed commands)</li> <li>exit_code</li> </ul> <p>Use <code>--json</code> to emit a machine-readable Result (for CI / GitHub Actions).</p>"},{"location":"concepts/documentation-contract/","title":"Documentation contract","text":"<p>This page defines documentation requirements and rules for Pantsagon releases.</p>"},{"location":"concepts/documentation-contract/#release-requirements","title":"Release requirements","text":"<p>Every release must include:</p> <ul> <li>updated CLI docs if flags changed</li> <li>updated schema docs if schemas changed</li> <li>updated diagnostic codes if codes changed</li> <li>updated pack docs if pack format or bundled packs changed</li> </ul>"},{"location":"concepts/documentation-contract/#versioning-rules","title":"Versioning rules","text":"<p>Documentation is published per tool version:</p> <ul> <li><code>dev</code> - tracks <code>main</code></li> <li><code>latest</code> - alias for the newest release</li> <li><code>vX.Y.Z</code> - tagged releases</li> <li><code>pr-&lt;num&gt;</code> - PR previews</li> </ul>"},{"location":"concepts/documentation-contract/#local-docs-workflow","title":"Local docs workflow","text":"<pre><code>pip install -r docs/requirements.txt\npip install pyyaml\npython scripts/generate_schema_docs.py\npython scripts/generate_diagnostic_codes.py\nmkdocs serve\n</code></pre>"},{"location":"concepts/documentation-contract/#generated-reference-docs","title":"Generated reference docs","text":"<p>Reference docs are generated and must not be edited by hand.</p> <ul> <li>generator scripts run in CI</li> <li>CI fails if <code>git diff</code> is non-empty after generation</li> <li>contributors must run generators locally before committing</li> </ul> <p>If you need to change reference docs, update the source files and re-run the generators.</p>"},{"location":"concepts/documentation-contract/#backlog","title":"Backlog","text":"<ul> <li>Docs: remove PR preview versions from mike on PR close</li> </ul>"},{"location":"concepts/hexagonal-architecture/","title":"Hexagonal architecture (generated repos)","text":"<p>Generated repos follow a strict layering model:</p> <ul> <li><code>domain</code>: pure rules and types (no IO)</li> <li><code>application</code>: use-cases (no concrete integrations)</li> <li><code>adapters</code>: integrations and IO (SDKs, HTTP, DB, etc.)</li> <li><code>entrypoints</code>: wiring (CLI/HTTP/workers)</li> </ul> <p>The critical property is dependency direction:</p> <ul> <li>domain depends only on itself (+ foundation)</li> <li>application depends on domain (+ foundation)</li> <li>adapters depend on application/domain (+ allowlisted shared adapters)</li> <li>entrypoints depend on adapters/application/domain</li> </ul>"},{"location":"concepts/packs/","title":"Packs","text":"<p>A pack is a versioned directory containing:</p> <ul> <li><code>pack.yaml</code> - tool-agnostic manifest (authoritative)</li> <li><code>copier.yml</code> - Copier rendering config</li> <li><code>templates/</code> - template files</li> </ul> <p>Pantsagon validates:</p> <ul> <li><code>pack.yaml</code> against a JSON Schema</li> <li><code>pack.yaml.variables</code> to <code>copier.yml</code> variable consistency</li> </ul> <p>Packs can be bundled with Pantsagon or loaded from a local directory in v1.</p>"},{"location":"concepts/repo-lock/","title":"Repo lock: .pantsagon.toml","text":"<p><code>.pantsagon.toml</code> is the single source of truth for:</p> <ul> <li>tool version</li> <li>selected packs (id/version/source)</li> <li>selected features and services</li> <li>resolved answers passed to the renderer</li> <li>strictness settings</li> </ul> <p>In v1:</p> <ul> <li>pack versions are pinned and never auto-upgraded</li> <li><code>add service</code> updates the lock deterministically</li> </ul>"},{"location":"concepts/trust-and-security/","title":"Trust and security","text":"<p>Packs are treated as untrusted content by default.</p> <ul> <li>hook execution is disabled unless explicitly allowed (or pack is trusted)</li> <li>v1 supports only bundled and local packs (no network fetching)</li> </ul> <p>Future:</p> <ul> <li>trust allowlist (local file)</li> <li>signed pack metadata</li> <li>registry-based distribution</li> </ul>"},{"location":"contributing/docs/","title":"Contributing to docs","text":"<p>Docs are part of the Pantsagon API surface. Keep them versioned and reproducible.</p>"},{"location":"contributing/docs/#where-to-edit","title":"Where to edit","text":"<ul> <li>user docs live in <code>docs/</code></li> <li>reference docs are generated from <code>schemas/</code> and <code>pantsagon/diagnostics/codes.yaml</code></li> </ul>"},{"location":"contributing/docs/#edit-links","title":"Edit links","text":"<p>Each page has an \"Edit this page\" link in the header. If you are a pack author or plugin author, start in Pack authoring or Plugin authoring.</p>"},{"location":"contributing/docs/#local-workflow","title":"Local workflow","text":"<pre><code>pip install -r docs/requirements.txt\npip install pyyaml\npython scripts/generate_schema_docs.py\npython scripts/generate_diagnostic_codes.py\nmkdocs serve\n</code></pre>"},{"location":"contributing/docs/#generated-files","title":"Generated files","text":"<p>Generated reference docs must not be edited by hand. Run the scripts above to update them.</p>"},{"location":"contributing/docs/#backlog","title":"Backlog","text":"<ul> <li>Docs: remove PR preview versions from mike on PR close</li> </ul>"},{"location":"getting-started/faq/","title":"FAQ","text":""},{"location":"getting-started/faq/#does-pantsagon-support-languages-other-than-python","title":"Does Pantsagon support languages other than Python?","text":"<p>Not in v1. The architecture supports multi-language packs later.</p>"},{"location":"getting-started/faq/#do-i-have-to-use-docker","title":"Do I have to use Docker?","text":"<p>No. Docker is a feature pack.</p>"},{"location":"getting-started/faq/#why-is-layering-enforced","title":"Why is layering enforced?","text":"<p>Because directory structure alone does not stop coupling. Enforcement makes the architecture real.</p>"},{"location":"getting-started/faq/#does-pantsagon-run-pants-during-generation","title":"Does Pantsagon run Pants during generation?","text":"<p>Only if you ask for it (for example, <code>validate --exec</code>), to keep init fast and predictable.</p>"},{"location":"getting-started/generated-repo-tour/","title":"Generated repo tour","text":"<p>A generated repo has these top-level areas:</p> <ul> <li><code>services/</code> - independently-deployable services</li> <li><code>shared/foundation/</code> - pure primitives, globally allowed</li> <li><code>shared/adapters/</code> - reusable integrations (allowlisted)</li> <li><code>tools/</code> - repo-owned checks (forbidden imports, validators)</li> <li><code>.pantsagon.toml</code> - pack pins and answers (source of truth)</li> </ul> <p>Each service follows:</p> <ul> <li><code>domain/</code>: pure business rules</li> <li><code>application/</code>: use-cases</li> <li><code>adapters/</code>: IO implementations</li> <li><code>entrypoints/</code>: CLI/HTTP/worker wiring</li> </ul> <p>The repo is designed so layering is enforced by Pants dependency rules.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":""},{"location":"getting-started/quickstart/#install-pantsagon","title":"Install Pantsagon","text":"<p>Recommended (isolated): - <code>pipx install pantsagon</code></p>"},{"location":"getting-started/quickstart/#create-a-repo","title":"Create a repo","text":"<pre><code>pantsagon init my-repo \\\n  --lang python \\\n  --services monitors,governance \\\n  --feature openapi \\\n  --feature docker\n</code></pre>"},{"location":"getting-started/quickstart/#add-a-service","title":"Add a service","text":"<pre><code>cd my-repo\npantsagon add service billing --lang python --feature docker\n</code></pre>"},{"location":"getting-started/quickstart/#validate","title":"Validate","text":"<pre><code>pantsagon validate\npantsagon validate --exec\n</code></pre> <ul> <li><code>validate</code> checks structure and manifests</li> <li><code>validate --exec</code> runs Pants goals (lint/check/test as configured)</li> </ul> <p>See CLI -&gt; init for full flags and semantics.</p>"},{"location":"pack-authoring/","title":"Pack authoring","text":"<p>Packs are the primary extension mechanism.</p> <p>A pack contains:</p> <ul> <li><code>pack.yaml</code> (authoritative manifest)</li> <li><code>copier.yml</code> (renderer config)</li> <li><code>templates/</code></li> </ul> <p>Pantsagon enforces:</p> <ul> <li>schema validation</li> <li>manifest to copier variable cross-check</li> <li>render smoke-test (for bundled packs)</li> </ul>"},{"location":"pack-authoring/pack-format/","title":"Pack format","text":"<p>Minimum pack structure:</p> <pre><code>&lt;pack&gt;/\n  pack.yaml\n  copier.yml\n  templates/\n</code></pre> <p><code>pack.yaml</code> declares:</p> <ul> <li>id + version</li> <li>compatibility</li> <li>requires/provides</li> <li>variables</li> </ul>"},{"location":"pack-authoring/publishing/","title":"Publishing","text":"<p>v1 supports:</p> <ul> <li>bundled packs (shipped with Pantsagon)</li> <li>local directory packs (user-provided paths)</li> </ul> <p>Future:</p> <ul> <li>git packs</li> <li>registry packs</li> </ul>"},{"location":"pack-authoring/validation/","title":"Validation","text":"<p>Bundled packs must pass:</p> <p>1) <code>pack.yaml</code> schema validation 2) manifest to copier variable cross-check 3) render smoke-test with minimal inputs</p>"},{"location":"pack-authoring/variables/","title":"Variables","text":"<p>Variables are declared in <code>pack.yaml</code> and mirrored in <code>copier.yml</code>.</p> <p>Policy:</p> <ul> <li>every manifest variable must exist in copier questions</li> <li>undeclared copier variables are errors (default)</li> <li>default mismatches are warnings (strict mode turns warnings into errors)</li> </ul>"},{"location":"plans/2026-01-10-docs-system/","title":"Docs System Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Implement a docs-as-code system with MkDocs + Material + mike, versioned publishing, reference-doc generators, and CI enforcement.</p> <p>Architecture: Documentation lives under <code>docs/</code> with a structured nav. Generated reference docs are produced by scripts from canonical sources (<code>schemas/</code> and <code>pantsagon/diagnostics/codes.yaml</code>) and CI fails if outputs drift. GitHub Actions publishes versioned docs to <code>gh-pages</code> using mike.</p> <p>Tech Stack: MkDocs + Material, mike, GitHub Actions, Python 3.12, PyYAML, JSON Schema.</p>"},{"location":"plans/2026-01-10-docs-system/#task-1-add-mkdocs-config-docs-dependency-pins-python-pin","title":"Task 1: Add MkDocs config + docs dependency pins + Python pin","text":"<p>Files: - Create: <code>mkdocs.yml</code> - Create: <code>docs/requirements.txt</code> - Create: <code>.python-version</code></p> <p>Step 1: Create <code>mkdocs.yml</code></p> <pre><code>site_name: Pantsagon\nsite_description: Hexagonal monorepos in Pants - generated with enforced boundaries.\nsite_url: https://engineeringergonomics.github.io/pantsagon/\nrepo_url: https://github.com/EngineeringErgonomics/pantsagon\nrepo_name: EngineeringErgonomics/pantsagon\nedit_uri: edit/main/docs/\n\ntheme:\n  name: material\n  language: en\n  features:\n    - navigation.instant\n    - navigation.instant.progress\n    - navigation.tracking\n    - navigation.sections\n    - navigation.expand\n    - navigation.path\n    - toc.follow\n    - content.action.edit\n    - content.code.copy\n    - content.tabs.link\n    - search.suggest\n    - search.highlight\n  icon:\n    repo: fontawesome/brands/github\n  palette:\n    - scheme: default\n      primary: indigo\n      accent: indigo\n\nplugins:\n  - search\n\nmarkdown_extensions:\n  - admonition\n  - attr_list\n  - def_list\n  - footnotes\n  - pymdownx.details\n  - pymdownx.superfences\n  - pymdownx.inlinehilite\n  - pymdownx.highlight:\n      anchor_linenums: true\n  - pymdownx.tabbed:\n      alternate_style: true\n  - toc:\n      permalink: true\n\nextra:\n  version:\n    provider: mike\n\nnav:\n  - Home: index.md\n\n  - Getting started:\n      - Quickstart: getting-started/quickstart.md\n      - Generated repo tour: getting-started/generated-repo-tour.md\n      - FAQ: getting-started/faq.md\n\n  - Concepts:\n      - Architecture: concepts/architecture.md\n      - Documentation contract: concepts/documentation-contract.md\n      - Hexagonal layering: concepts/hexagonal-architecture.md\n      - Packs: concepts/packs.md\n      - Repo lock: concepts/repo-lock.md\n      - Diagnostics: concepts/diagnostics.md\n      - Trust model: concepts/trust-and-security.md\n\n  - CLI:\n      - Overview: cli/index.md\n      - init: cli/init.md\n      - add service: cli/add-service.md\n      - validate: cli/validate.md\n      - Exit codes: cli/exit-codes.md\n\n  - Pack authoring:\n      - Overview: pack-authoring/index.md\n      - Pack format: pack-authoring/pack-format.md\n      - Variables: pack-authoring/variables.md\n      - Validation: pack-authoring/validation.md\n      - Publishing: pack-authoring/publishing.md\n\n  - Plugin authoring:\n      - Overview: plugin-authoring/index.md\n      - Ports: plugin-authoring/ports.md\n      - Adapters: plugin-authoring/adapters.md\n      - Discovery: plugin-authoring/discovery.md\n\n  - Reference:\n      - Schemas:\n          - pack.schema.v1: reference/pack.schema.v1.md\n          - repo lock schema: reference/repo-lock.schema.v1.md\n          - result schema: reference/result.schema.v1.md\n      - Diagnostic codes: reference/diagnostic-codes.md\n\n  - Contributing:\n      - Docs: contributing/docs.md\n</code></pre> <p>Step 2: Create <code>docs/requirements.txt</code></p> <pre><code>mkdocs-material==9.5.36\nmike==2.1.2\n</code></pre> <p>Step 3: Create <code>.python-version</code></p> <pre><code>3.12.0\n</code></pre> <p>Step 4: Commit</p> <pre><code>git add mkdocs.yml docs/requirements.txt .python-version\ngit commit -m \"docs: add mkdocs config and pinned deps\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-2-create-docs-tree-starter-content-contract-contributing-page","title":"Task 2: Create docs tree + starter content + contract + contributing page","text":"<p>Files: - Create: <code>docs/index.md</code> - Create: <code>docs/getting-started/quickstart.md</code> - Create: <code>docs/getting-started/generated-repo-tour.md</code> - Create: <code>docs/getting-started/faq.md</code> - Create: <code>docs/concepts/architecture.md</code> - Create: <code>docs/concepts/documentation-contract.md</code> - Create: <code>docs/concepts/hexagonal-architecture.md</code> - Create: <code>docs/concepts/packs.md</code> - Create: <code>docs/concepts/repo-lock.md</code> - Create: <code>docs/concepts/diagnostics.md</code> - Create: <code>docs/concepts/trust-and-security.md</code> - Create: <code>docs/cli/index.md</code> - Create: <code>docs/cli/init.md</code> - Create: <code>docs/cli/add-service.md</code> - Create: <code>docs/cli/validate.md</code> - Create: <code>docs/cli/exit-codes.md</code> - Create: <code>docs/pack-authoring/index.md</code> - Create: <code>docs/pack-authoring/pack-format.md</code> - Create: <code>docs/pack-authoring/variables.md</code> - Create: <code>docs/pack-authoring/validation.md</code> - Create: <code>docs/pack-authoring/publishing.md</code> - Create: <code>docs/plugin-authoring/index.md</code> - Create: <code>docs/plugin-authoring/ports.md</code> - Create: <code>docs/plugin-authoring/adapters.md</code> - Create: <code>docs/plugin-authoring/discovery.md</code> - Create: <code>docs/contributing/docs.md</code></p> <p>Step 1: Create <code>docs/index.md</code></p> <pre><code># Pantsagon\n\nPantsagon bootstraps **hexagonal monorepos** managed by **Pants**, with enforcement from day one.\n\nYou use Pantsagon to generate a repository where:\n\n- each service is structured as `domain/`, `application/`, `adapters/`, `entrypoints/`\n- shared code is split into **foundation** (pure) and **shared adapters** (allowlisted integrations)\n- dependency boundaries hard-fail locally and in CI\n- optional packs add contract-first OpenAPI and Docker packaging\n\n## What you can do in v1\n\n- `pantsagon init` - create a new monorepo\n- `pantsagon add service` - add a new service skeleton\n- `pantsagon validate` - validate invariants and optionally run Pants checks\n\n## Key concepts\n\n- **Packs**: versioned templates (`pack.yaml` + `copier.yml` + `templates/`)\n- **Repo lock**: `.pantsagon.toml` is the single source of truth for pack pins and answers\n- **Diagnostics**: structured errors/warnings emitted by all frontends\n\nStart with **Getting started \u2192 Quickstart**.\n\nLooking to contribute? See **Contributing \u2192 Docs**.\n</code></pre> <p>Step 2: Create Getting started pages</p> <pre><code># Quickstart\n\n## Install Pantsagon\n\nRecommended (isolated):\n- `pipx install pantsagon`\n\n## Create a repo\n\n```bash\npantsagon init my-repo \\\n  --lang python \\\n  --services monitors,governance \\\n  --feature openapi \\\n  --feature docker\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#add-a-service","title":"Add a service","text":"<pre><code>cd my-repo\npantsagon add service billing --lang python --feature docker\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#validate","title":"Validate","text":"<pre><code>pantsagon validate\npantsagon validate --exec\n</code></pre> <ul> <li><code>validate</code> checks structure and manifests</li> <li><code>validate --exec</code> runs Pants goals (lint/check/test as configured)</li> </ul> <p>See CLI \u2192 init for full flags and semantics. <pre><code>```md\n# Generated repo tour\n\nA generated repo has these top-level areas:\n\n- `services/` - independently-deployable services\n- `shared/foundation/` - pure primitives, globally allowed\n- `shared/adapters/` - reusable integrations (allowlisted)\n- `tools/` - repo-owned checks (e.g., forbidden imports)\n- `.pantsagon.toml` - pack pins and answers (source of truth)\n\nEach service follows:\n\n- `domain/`: pure business rules\n- `application/`: use-cases\n- `adapters/`: IO implementations\n- `entrypoints/`: CLI/HTTP/worker wiring\n\nThe repo is designed so layering is enforced by Pants dependency rules.\n</code></pre></p> <pre><code># FAQ\n\n## Does Pantsagon support languages other than Python?\n\nNot in v1. The architecture supports multi-language packs later.\n\n## Do I have to use Docker?\n\nNo. Docker is a feature pack.\n\n## Why is layering enforced?\n\nBecause \u201cdirectory structure\u201d alone does not stop coupling. Enforcement makes the architecture real.\n\n## Does Pantsagon run Pants during generation?\n\nOnly if you ask for it (e.g., `validate --exec`), to keep init fast and predictable.\n</code></pre> <p>Step 3: Create Concepts pages (including documentation contract)</p> <pre><code># Architecture\n\nPantsagon itself is hexagonal:\n\n- **Domain** models `Blueprint \u2192 PackSelection \u2192 RenderPlan \u2192 RepoLock \u2192 Diagnostics`\n- **Application** orchestrates `init`, `add service`, and `validate`\n- **Ports** define pack discovery, rendering, workspace IO, policy checks, and command execution\n- **Adapters** implement those ports (Copier renderer, filesystem workspace, bundled/local packs)\n\nThis lets Pantsagon support multiple frontends and third-party extensions without forking.\n</code></pre> <pre><code># Documentation contract\n\nThis page defines the documentation requirements and rules for Pantsagon releases.\n\n## Release requirements\n\nEvery release must include:\n\n- updated CLI docs if flags changed\n- updated schema docs if schemas changed\n- updated diagnostic codes if codes changed\n- updated pack docs if pack format or bundled packs changed\n\n## Versioning rules\n\nDocumentation is published per tool version:\n\n- `dev` - tracks `main`\n- `latest` - alias for the newest release\n- `vX.Y.Z` - tagged releases\n- `pr-&lt;num&gt;` - PR previews\n\n## Local docs workflow\n\n```bash\npip install -r docs/requirements.txt\npip install pyyaml\npython scripts/generate_schema_docs.py\npython scripts/generate_diagnostic_codes.py\nmkdocs serve\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#generated-reference-docs","title":"Generated reference docs","text":"<p>Reference docs are generated and must not be edited by hand.</p> <ul> <li>generator scripts run in CI</li> <li>CI fails if <code>git diff</code> is non-empty after generation</li> <li>contributors must run generators locally before committing</li> </ul> <p>If you need to change reference docs, update the source files and re-run the generators. <pre><code>```md\n# Hexagonal architecture (generated repos)\n\nGenerated repos follow a strict layering model:\n\n- `domain`: pure rules and types (no IO)\n- `application`: use-cases (no concrete integrations)\n- `adapters`: integrations and IO (SDKs, HTTP, DB, etc.)\n- `entrypoints`: wiring (CLI/HTTP/workers)\n\nThe critical property is **dependency direction**:\n- domain depends only on itself (+ foundation)\n- application depends on domain (+ foundation)\n- adapters depend on application/domain (+ allowlisted shared adapters)\n- entrypoints depend on adapters/application/domain\n</code></pre></p> <pre><code># Packs\n\nA pack is a versioned directory containing:\n\n- `pack.yaml` - tool-agnostic manifest (authoritative)\n- `copier.yml` - Copier rendering config\n- `templates/` - template files\n\nPantsagon validates:\n- `pack.yaml` against a JSON Schema\n- `pack.yaml.variables` \u2194 `copier.yml` variables consistency\n\nPacks can be bundled with Pantsagon or loaded from a local directory in v1.\n</code></pre> <pre><code># Repo lock: .pantsagon.toml\n\n`.pantsagon.toml` is the single source of truth for:\n\n- tool version\n- selected packs (id/version/source)\n- selected features and services\n- resolved answers passed to the renderer\n- strictness settings\n\nIn v1:\n- pack versions are pinned and never auto-upgraded\n- `add service` updates the lock deterministically\n</code></pre> <pre><code># Diagnostics\n\nAll frontends emit structured diagnostics:\n\n- code (stable identifier)\n- rule (stable rule id / namespace)\n- severity (error|warn|info)\n- message\n- optional location/hint/details\n\nCommands return a `Result`:\n- diagnostics\n- artifacts (written paths, applied packs, executed commands)\n- exit_code\n\nUse `--json` to emit a machine-readable Result (for CI / GH Actions).\n</code></pre> <pre><code># Trust and security\n\nPacks are treated as untrusted content by default.\n\n- Hook execution is disabled unless explicitly allowed (or pack is trusted).\n- v1 supports only bundled and local packs (no network fetching).\n\nFuture:\n- trust allowlist (local file)\n- signed pack metadata\n- registry-based distribution\n</code></pre> <p>Step 4: Create CLI pages</p> <pre><code># CLI overview\n\nv1 commands:\n\n- `pantsagon init`\n- `pantsagon add service`\n- `pantsagon validate`\n\nAll commands support structured diagnostics and stable exit codes.\n</code></pre> <pre><code># pantsagon init\n\nCreate a new monorepo.\n\n```bash\npantsagon init &lt;repo&gt;\n</code></pre> <p>Common flags:</p> <ul> <li><code>--lang python</code> (required in v1)</li> <li><code>--services a,b</code></li> <li><code>--feature openapi</code> (repeatable)</li> <li><code>--feature docker</code> (repeatable)</li> <li><code>--strict</code></li> <li><code>--renderer copier</code></li> <li><code>--non-interactive</code> <pre><code>```md\n# pantsagon add service\n\nAdd a new service skeleton into an existing Pantsagon repo.\n\n```bash\npantsagon add service &lt;name&gt; --lang python\n</code></pre></li> </ul> <p>Optional:</p> <ul> <li><code>--feature openapi</code></li> <li><code>--feature docker</code></li> <li><code>--strict</code> <pre><code>```md\n# pantsagon validate\n\nValidate `.pantsagon.toml`, packs, and repo invariants.\n\n```bash\npantsagon validate\n</code></pre></li> </ul> <p>Flags:</p> <ul> <li><code>--exec</code> runs configured Pants goals (lint/check/test etc.)</li> <li><code>--strict</code> upgrades warnings to errors</li> <li><code>--json</code> outputs machine-readable Result <pre><code>```md\n# Exit codes\n\nStable exit codes:\n\n- `0` success\n- `2` validation failure (schema/invariants/compatibility)\n- `3` execution failure (IO/renderer/subprocess)\n- `4` internal error (unexpected exception)\n</code></pre></li> </ul> <p>Step 5: Create Pack authoring pages</p> <pre><code># Pack authoring\n\nPacks are the primary extension mechanism.\n\nA pack contains:\n- `pack.yaml` (authoritative manifest)\n- `copier.yml` (renderer config)\n- `templates/`\n\nPantsagon enforces:\n- schema validation\n- manifest \u2194 copier variable cross-check\n- render smoke-test (for bundled packs)\n</code></pre> <pre><code># Pack format\n\nMinimum pack structure:\n\n```text\n&lt;pack&gt;/\n  pack.yaml\n  copier.yml\n  templates/\n</code></pre> <p><code>pack.yaml</code> declares:</p> <ul> <li>id + version</li> <li>compatibility</li> <li>requires/provides</li> <li>variables <pre><code>```md\n# Variables\n\nVariables are declared in `pack.yaml` and mirrored in `copier.yml`.\n\nPolicy:\n- every manifest variable must exist in copier questions\n- undeclared copier variables are errors (default)\n- default mismatches are warnings (strict mode =&gt; errors)\n</code></pre></li> </ul> <pre><code># Validation\n\nBundled packs must pass:\n1) `pack.yaml` schema validation\n2) manifest \u2194 copier variable cross-check\n3) render smoke-test with minimal inputs\n</code></pre> <pre><code># Publishing\n\nv1 supports:\n- bundled packs (shipped with Pantsagon)\n- local directory packs (user-provided paths)\n\nFuture:\n- git packs\n- registry packs\n</code></pre> <p>Step 6: Create Plugin authoring pages</p> <pre><code># Plugin authoring\n\nPlugins provide adapter implementations for ports (future scope).\n\nIn v1, plugins are not loaded, but the port contracts are designed for it.\n</code></pre> <pre><code># Ports\n\nCore ports:\n- PackCatalogPort\n- RendererPort\n- WorkspacePort\n- PolicyEnginePort\n- CommandPort\n\nPorts accept and return domain objects and must not leak implementation details.\n</code></pre> <pre><code># Adapters\n\nAdapters implement ports.\nThey should:\n- raise typed AdapterError on IO/exec failures\n- return Result/Diagnostics for expected validation outcomes\n</code></pre> <pre><code># Discovery (future)\n\nFuture plugins will be discovered via Python entry points, grouped by port:\n\n- pantsagon.pack_catalog\n- pantsagon.renderer\n- pantsagon.workspace\n- pantsagon.policy_engine\n- pantsagon.command_runner\n</code></pre> <p>Step 7: Create Contributing docs page</p> <pre><code># Contributing to docs\n\nDocs are part of the Pantsagon API surface. Keep them versioned and reproducible.\n\n## Where to edit\n\n- User docs live in `docs/`\n- Reference docs are generated from `schemas/` and `pantsagon/diagnostics/codes.yaml`\n\n## Edit links\n\nEach page has an \u201cEdit this page\u201d link in the header.\nIf you\u2019re a pack author or plugin author, start in **Pack authoring** or **Plugin authoring**.\n\n## Local workflow\n\n```bash\npip install -r docs/requirements.txt\npip install pyyaml\npython scripts/generate_schema_docs.py\npython scripts/generate_diagnostic_codes.py\nmkdocs serve\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#generated-files","title":"Generated files","text":"<p>Generated reference docs must not be edited by hand. Run the scripts above to update them.</p>"},{"location":"plans/2026-01-10-docs-system/#backlog","title":"Backlog","text":"<ul> <li>Docs: remove PR preview versions from mike on PR close <pre><code>**Step 8: Commit**\n\n```bash\ngit add docs/index.md \\\n  docs/getting-started/quickstart.md \\\n  docs/getting-started/generated-repo-tour.md \\\n  docs/getting-started/faq.md \\\n  docs/concepts/architecture.md \\\n  docs/concepts/documentation-contract.md \\\n  docs/concepts/hexagonal-architecture.md \\\n  docs/concepts/packs.md \\\n  docs/concepts/repo-lock.md \\\n  docs/concepts/diagnostics.md \\\n  docs/concepts/trust-and-security.md \\\n  docs/cli/index.md \\\n  docs/cli/init.md \\\n  docs/cli/add-service.md \\\n  docs/cli/validate.md \\\n  docs/cli/exit-codes.md \\\n  docs/pack-authoring/index.md \\\n  docs/pack-authoring/pack-format.md \\\n  docs/pack-authoring/variables.md \\\n  docs/pack-authoring/validation.md \\\n  docs/pack-authoring/publishing.md \\\n  docs/plugin-authoring/index.md \\\n  docs/plugin-authoring/ports.md \\\n  docs/plugin-authoring/adapters.md \\\n  docs/plugin-authoring/discovery.md \\\n  docs/contributing/docs.md\ngit commit -m \"docs: add starter content and contributor guidance\"\n</code></pre></li> </ul>"},{"location":"plans/2026-01-10-docs-system/#task-3-add-failing-tests-for-schema-doc-generator-tdd","title":"Task 3: Add failing tests for schema-doc generator (TDD)","text":"<p>Files: - Create: <code>tests/test_generate_schema_docs.py</code> - Create: <code>scripts/__init__.py</code></p> <p>Step 1: Create <code>scripts/__init__.py</code></p> <pre><code># Intentionally empty to allow imports in tests.\n</code></pre> <p>Step 2: Write the failing test <code>tests/test_generate_schema_docs.py</code></p> <pre><code>import json\nimport tempfile\nimport unittest\nfrom pathlib import Path\n\nfrom scripts import generate_schema_docs\n\n\nclass GenerateSchemaDocsTest(unittest.TestCase):\n    def test_generates_markdown_from_schemas(self) -&gt; None:\n        with tempfile.TemporaryDirectory() as tmpdir:\n            repo_root = Path(tmpdir)\n            schemas_dir = repo_root / \"schemas\"\n            schemas_dir.mkdir(parents=True)\n            (repo_root / \"docs\" / \"reference\").mkdir(parents=True)\n\n            def write_schema(name: str, title: str) -&gt; None:\n                (schemas_dir / name).write_text(\n                    json.dumps(\n                        {\n                            \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n                            \"$id\": f\"https://example.test/{name}\",\n                            \"title\": title,\n                            \"description\": f\"{title} description\",\n                            \"type\": \"object\",\n                            \"properties\": {\"alpha\": {\"type\": \"string\"}},\n                            \"required\": [\"alpha\"],\n                        }\n                    ),\n                    encoding=\"utf-8\",\n                )\n\n            write_schema(\"pack.schema.v1.json\", \"Pack Schema\")\n            write_schema(\"repo-lock.schema.v1.json\", \"Repo Lock Schema\")\n            write_schema(\"result.schema.v1.json\", \"Result Schema\")\n\n            generate_schema_docs.generate(repo_root)\n\n            out = (repo_root / \"docs\" / \"reference\" / \"pack.schema.v1.md\").read_text(\n                encoding=\"utf-8\"\n            )\n            self.assertIn(\"Generated file. Do not edit directly.\", out)\n            self.assertIn(\"# Pack Schema\", out)\n            self.assertIn(\"alpha\", out)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre> <p>Step 3: Run the test to verify it fails</p> <p>Run: <code>python -m unittest tests/test_generate_schema_docs.py -v</code></p> <p>Expected: FAIL with <code>AttributeError</code> or <code>ImportError</code> because <code>generate_schema_docs.generate</code> does not exist yet.</p> <p>Step 4: Commit</p> <pre><code>git add scripts/__init__.py tests/test_generate_schema_docs.py\ngit commit -m \"test: add schema docs generator test\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-4-implement-schema-doc-generator-to-pass-tests","title":"Task 4: Implement schema-doc generator to pass tests","text":"<p>Files: - Create: <code>scripts/generate_schema_docs.py</code></p> <p>Step 1: Write minimal implementation <code>scripts/generate_schema_docs.py</code></p> <pre><code>#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport json\nfrom pathlib import Path\nfrom typing import Any\n\n\nREPO_ROOT = Path(__file__).resolve().parents[1]\n\nSCHEMA_MAP = {\n    \"pack.schema.v1.json\": \"pack.schema.v1.md\",\n    \"repo-lock.schema.v1.json\": \"repo-lock.schema.v1.md\",\n    \"result.schema.v1.json\": \"result.schema.v1.md\",\n}\n\n\ndef _load_json(path: Path) -&gt; dict[str, Any]:\n    return json.loads(path.read_text(encoding=\"utf-8\"))\n\n\ndef _md_escape(s: str) -&gt; str:\n    return s.replace(\"&lt;\", \"&amp;lt;\").replace(\"&gt;\", \"&amp;gt;\")\n\n\ndef _render_generated_notice(command: str) -&gt; str:\n    return \"\\n\".join(\n        [\n            \"&gt; **Generated file. Do not edit directly.**\",\n            f\"&gt; Run: `{command}`\",\n        ]\n    )\n\n\ndef _render_schema_overview(schema: dict[str, Any]) -&gt; str:\n    title = schema.get(\"title\") or \"Schema\"\n    desc = schema.get(\"description\") or \"\"\n    schema_id = schema.get(\"$id\") or \"\"\n    schema_version = schema.get(\"$schema\") or \"\"\n\n    lines: list[str] = []\n    lines.append(f\"# {_md_escape(title)}\")\n    if desc:\n        lines.append(\"\")\n        lines.append(desc.strip())\n    if schema_id or schema_version:\n        lines.append(\"\")\n        if schema_id:\n            lines.append(f\"- **$id**: `{schema_id}`\")\n        if schema_version:\n            lines.append(f\"- **$schema**: `{schema_version}`\")\n    return \"\\n\".join(lines)\n\n\ndef _render_properties(schema: dict[str, Any]) -&gt; str:\n    props: dict[str, Any] = schema.get(\"properties\") or {}\n    required: set[str] = set(schema.get(\"required\") or [])\n\n    if not props:\n        return \"## Properties\\n\\n(No top-level properties declared.)\"\n\n    lines: list[str] = []\n    lines.append(\"## Properties\")\n    lines.append(\"\")\n    lines.append(\"| Name | Type | Required | Description |\")\n    lines.append(\"|---|---|---:|---|\")\n\n    for name in sorted(props.keys()):\n        p = props[name] or {}\n        p_type = p.get(\"type\")\n        if isinstance(p_type, list):\n            type_str = \" | \".join(str(t) for t in p_type)\n        else:\n            type_str = str(p_type) if p_type is not None else \"(unspecified)\"\n        desc = (p.get(\"description\") or \"\").strip().replace(\"\\n\", \" \")\n        lines.append(\n            f\"| `{name}` | `{type_str}` | {'yes' if name in required else 'no'} | {desc} |\"\n        )\n\n    return \"\\n\".join(lines)\n\n\ndef _render_raw(schema: dict[str, Any]) -&gt; str:\n    pretty = json.dumps(schema, indent=2, sort_keys=True)\n    return \"## Raw JSON\\n\\n```json\\n\" + pretty + \"\\n```\\n\"\n\n\ndef generate(repo_root: Path = REPO_ROOT) -&gt; None:\n    schemas_dir = repo_root / \"schemas\"\n    out_dir = repo_root / \"docs\" / \"reference\"\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    for in_name, out_name in SCHEMA_MAP.items():\n        in_path = schemas_dir / in_name\n        if not in_path.exists():\n            raise SystemExit(f\"Schema file not found: {in_path}\")\n\n        schema = _load_json(in_path)\n        md = \"\\n\\n\".join(\n            [\n                _render_generated_notice(\"python scripts/generate_schema_docs.py\"),\n                _render_schema_overview(schema),\n                _render_properties(schema),\n                _render_raw(schema),\n            ]\n        )\n        out_path = out_dir / out_name\n        out_path.write_text(md + \"\\n\", encoding=\"utf-8\")\n\n    print(f\"Generated schema docs into {out_dir}\")\n\n\nif __name__ == \"__main__\":\n    generate()\n</code></pre> <p>Step 2: Run tests to verify pass</p> <p>Run: <code>python -m unittest tests/test_generate_schema_docs.py -v</code></p> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add scripts/generate_schema_docs.py\ngit commit -m \"feat: add schema docs generator\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-5-add-failing-tests-for-diagnostic-codes-generator-tdd","title":"Task 5: Add failing tests for diagnostic-codes generator (TDD)","text":"<p>Files: - Create: <code>tests/test_generate_diagnostic_codes.py</code></p> <p>Step 1: Write the failing test <code>tests/test_generate_diagnostic_codes.py</code></p> <pre><code>import tempfile\nimport unittest\nfrom pathlib import Path\n\nfrom scripts import generate_diagnostic_codes\n\n\nclass GenerateDiagnosticCodesTest(unittest.TestCase):\n    def test_generates_markdown_from_codes_yaml(self) -&gt; None:\n        with tempfile.TemporaryDirectory() as tmpdir:\n            repo_root = Path(tmpdir)\n            src = repo_root / \"pantsagon\" / \"diagnostics\"\n            src.mkdir(parents=True)\n            (repo_root / \"docs\" / \"reference\").mkdir(parents=True)\n\n            (src / \"codes.yaml\").write_text(\n                \"\"\"\nversion: 1\ncodes:\n  - code: EXAMPLE_CODE\n    severity: error\n    rule: example.rule\n    message: Example message\n    hint: Example hint\n\"\"\".lstrip(),\n                encoding=\"utf-8\",\n            )\n\n            generate_diagnostic_codes.generate(repo_root)\n\n            out = (repo_root / \"docs\" / \"reference\" / \"diagnostic-codes.md\").read_text(\n                encoding=\"utf-8\"\n            )\n            self.assertIn(\"Generated file. Do not edit directly.\", out)\n            self.assertIn(\"EXAMPLE_CODE\", out)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre> <p>Step 2: Run the test to verify it fails</p> <p>Run: <code>python -m unittest tests/test_generate_diagnostic_codes.py -v</code></p> <p>Expected: FAIL with <code>AttributeError</code> or <code>ImportError</code> because <code>generate_diagnostic_codes.generate</code> does not exist yet.</p> <p>Step 3: Commit</p> <pre><code>git add tests/test_generate_diagnostic_codes.py\ngit commit -m \"test: add diagnostic codes generator test\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-6-implement-diagnostic-codes-generator-to-pass-tests","title":"Task 6: Implement diagnostic-codes generator to pass tests","text":"<p>Files: - Create: <code>scripts/generate_diagnostic_codes.py</code></p> <p>Step 1: Write minimal implementation <code>scripts/generate_diagnostic_codes.py</code></p> <pre><code>#!/usr/bin/env python3\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any\n\nimport yaml\n\n\nREPO_ROOT = Path(__file__).resolve().parents[1]\n\n\ndef _load_yaml(path: Path) -&gt; dict[str, Any]:\n    return yaml.safe_load(path.read_text(encoding=\"utf-8\")) or {}\n\n\ndef _render_generated_notice(command: str) -&gt; str:\n    return \"\\n\".join(\n        [\n            \"&gt; **Generated file. Do not edit directly.**\",\n            f\"&gt; Run: `{command}`\",\n        ]\n    )\n\n\ndef generate(repo_root: Path = REPO_ROOT) -&gt; None:\n    src = repo_root / \"pantsagon\" / \"diagnostics\" / \"codes.yaml\"\n    out = repo_root / \"docs\" / \"reference\" / \"diagnostic-codes.md\"\n\n    if not src.exists():\n        raise SystemExit(f\"Diagnostics source not found: {src}\")\n\n    data = _load_yaml(src)\n    if data.get(\"version\") != 1:\n        raise SystemExit(f\"Unsupported diagnostics version: {data.get('version')}\")\n\n    codes = data.get(\"codes\")\n    if not isinstance(codes, list):\n        raise SystemExit(\"Invalid codes.yaml: expected top-level 'codes' list\")\n\n    lines: list[str] = []\n    lines.append(_render_generated_notice(\"python scripts/generate_diagnostic_codes.py\"))\n    lines.append(\"\")\n    lines.append(\"# Diagnostic codes\")\n    lines.append(\"\")\n    lines.append(\"This page is generated from `pantsagon/diagnostics/codes.yaml`.\")\n    lines.append(\"\")\n    lines.append(\"| Code | Severity | Rule | Message | Hint |\")\n    lines.append(\"|---|---|---|---|---|\")\n\n    for item in sorted(codes, key=lambda x: (x.get(\"code\") or \"\")):\n        code = (item.get(\"code\") or \"\").strip()\n        sev = (item.get(\"severity\") or \"\").strip()\n        rule = (item.get(\"rule\") or \"\").strip()\n        msg = (item.get(\"message\") or \"\").strip().replace(\"\\n\", \" \")\n        hint = (item.get(\"hint\") or \"\").strip().replace(\"\\n\", \" \")\n\n        if not code or not sev or not rule:\n            raise SystemExit(f\"Invalid diagnostic entry (missing required fields): {item}\")\n\n        lines.append(f\"| `{code}` | `{sev}` | `{rule}` | {msg} | {hint} |\")\n\n    out.parent.mkdir(parents=True, exist_ok=True)\n    out.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n    print(f\"Generated {out}\")\n\n\nif __name__ == \"__main__\":\n    generate()\n</code></pre> <p>Step 2: Run tests to verify pass</p> <p>Run: <code>python -m unittest tests/test_generate_diagnostic_codes.py -v</code></p> <p>Expected: PASS</p> <p>Step 3: Commit</p> <pre><code>git add scripts/generate_diagnostic_codes.py\ngit commit -m \"feat: add diagnostic codes generator\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-7-add-schemas-diagnostics-codes-source","title":"Task 7: Add schemas + diagnostics codes source","text":"<p>Files: - Create: <code>schemas/pack.schema.v1.json</code> - Create: <code>schemas/repo-lock.schema.v1.json</code> - Create: <code>schemas/result.schema.v1.json</code> - Create: <code>pantsagon/diagnostics/codes.yaml</code></p> <p>Step 1: Create <code>schemas/pack.schema.v1.json</code></p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://pantsagon.dev/schemas/pack.schema.v1.json\",\n  \"title\": \"Pantsagon Pack Manifest (v1)\",\n  \"description\": \"Tool-agnostic manifest describing a Pantsagon pack: identity, compatibility, features, and variables.\",\n  \"type\": \"object\",\n  \"required\": [\"id\", \"version\", \"compatibility\"],\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"schema_version\": {\n      \"type\": \"integer\",\n      \"const\": 1,\n      \"description\": \"Schema version for this manifest.\"\n    },\n    \"id\": {\n      \"type\": \"string\",\n      \"pattern\": \"^[a-z0-9_.-]+$\",\n      \"description\": \"Globally unique pack identifier (e.g. pantsagon.python).\"\n    },\n    \"version\": {\n      \"type\": \"string\",\n      \"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\",\n      \"description\": \"SemVer version of the pack.\"\n    },\n    \"description\": {\n      \"type\": \"string\",\n      \"description\": \"Human-readable description of the pack.\"\n    },\n    \"compatibility\": {\n      \"type\": \"object\",\n      \"required\": [\"pants\"],\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"pants\": {\n          \"type\": \"string\",\n          \"description\": \"Supported Pants version range (PEP 440 / semver-style range).\"\n        },\n        \"languages\": {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"string\",\n            \"description\": \"Supported version range for a language (e.g. python: \\\"&gt;=3.12,&lt;3.15\\\").\"\n          }\n        }\n      }\n    },\n    \"requires\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"packs\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[a-z0-9_.-]+$\"\n          },\n          \"description\": \"Other packs that must be present for this pack to be applied.\"\n        }\n      }\n    },\n    \"provides\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"features\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"string\" },\n          \"description\": \"Feature flags provided by this pack (e.g. openapi, docker).\"\n        },\n        \"service_templates\": {\n          \"type\": \"array\",\n          \"description\": \"Service template capabilities exposed by this pack.\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\"kind\", \"language\"],\n            \"additionalProperties\": false,\n            \"properties\": {\n              \"kind\": {\n                \"type\": \"string\",\n                \"enum\": [\"service\"],\n                \"description\": \"Template kind.\"\n              },\n              \"language\": {\n                \"type\": \"string\",\n                \"description\": \"Language supported by this template.\"\n              },\n              \"layout\": {\n                \"type\": \"string\",\n                \"description\": \"Declared layout (e.g. hexagonal).\"\n              }\n            }\n          }\n        }\n      }\n    },\n    \"variables\": {\n      \"type\": \"array\",\n      \"description\": \"Variables required or accepted by this pack.\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"name\", \"type\"],\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[a-zA-Z_][a-zA-Z0-9_]*$\",\n            \"description\": \"Variable name.\"\n          },\n          \"type\": {\n            \"type\": \"string\",\n            \"enum\": [\"string\", \"int\", \"bool\", \"enum\"],\n            \"description\": \"Variable type.\"\n          },\n          \"default\": {\n            \"description\": \"Default value if not provided.\"\n          },\n          \"required\": {\n            \"type\": \"boolean\",\n            \"default\": false,\n            \"description\": \"Whether the variable is required.\"\n          },\n          \"enum\": {\n            \"type\": \"array\",\n            \"items\": { \"type\": \"string\" },\n            \"description\": \"Allowed values when type is enum.\"\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Step 2: Create <code>schemas/repo-lock.schema.v1.json</code></p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://pantsagon.dev/schemas/repo-lock.schema.v1.json\",\n  \"title\": \"Pantsagon Repo Lock (.pantsagon.toml) (v1)\",\n  \"description\": \"Single source of truth for a Pantsagon-generated repository.\",\n  \"type\": \"object\",\n  \"required\": [\"tool\", \"resolved\"],\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"tool\": {\n      \"type\": \"object\",\n      \"required\": [\"name\", \"version\"],\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\",\n          \"const\": \"pantsagon\"\n        },\n        \"version\": {\n          \"type\": \"string\",\n          \"description\": \"Pantsagon tool version used to generate or update this repo.\"\n        }\n      }\n    },\n    \"settings\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"renderer\": {\n          \"type\": \"string\",\n          \"default\": \"copier\",\n          \"description\": \"Renderer adapter to use.\"\n        },\n        \"strict\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"Whether strict mode is enabled.\"\n        },\n        \"strict_manifest\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"Whether manifest/Copier mismatches are fatal.\"\n        },\n        \"allow_hooks\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"Whether pack hooks are allowed to execute.\"\n        }\n      }\n    },\n    \"selection\": {\n      \"type\": \"object\",\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"languages\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"string\" }\n        },\n        \"features\": {\n          \"type\": \"array\",\n          \"items\": { \"type\": \"string\" }\n        },\n        \"services\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\",\n            \"pattern\": \"^[a-z][a-z0-9-]*$\"\n          }\n        }\n      }\n    },\n    \"resolved\": {\n      \"type\": \"object\",\n      \"required\": [\"packs\"],\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"packs\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"required\": [\"id\", \"version\", \"source\"],\n            \"additionalProperties\": false,\n            \"properties\": {\n              \"id\": {\n                \"type\": \"string\"\n              },\n              \"version\": {\n                \"type\": \"string\"\n              },\n              \"source\": {\n                \"type\": \"string\",\n                \"enum\": [\"bundled\", \"local\", \"git\", \"registry\"]\n              },\n              \"location\": {\n                \"type\": \"string\",\n                \"description\": \"Filesystem path or URL, depending on source.\"\n              },\n              \"ref\": {\n                \"type\": \"string\",\n                \"description\": \"Git ref, commit, or registry digest.\"\n              }\n            }\n          }\n        },\n        \"answers\": {\n          \"type\": \"object\",\n          \"additionalProperties\": true,\n          \"description\": \"Resolved variable answers passed to the renderer.\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Step 3: Create <code>schemas/result.schema.v1.json</code></p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://pantsagon.dev/schemas/result.schema.v1.json\",\n  \"title\": \"Pantsagon Result (v1)\",\n  \"description\": \"Structured output returned by Pantsagon commands for humans and machines.\",\n  \"type\": \"object\",\n  \"required\": [\"result_schema_version\", \"exit_code\", \"diagnostics\"],\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"result_schema_version\": {\n      \"type\": \"integer\",\n      \"const\": 1,\n      \"description\": \"Schema version for the Result object.\"\n    },\n    \"exit_code\": {\n      \"type\": \"integer\",\n      \"enum\": [0, 2, 3, 4],\n      \"description\": \"Process exit code.\"\n    },\n    \"diagnostics\": {\n      \"type\": \"array\",\n      \"description\": \"Structured diagnostics emitted during execution.\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"code\", \"rule\", \"severity\", \"message\"],\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"description\": \"Stable or deterministic diagnostic identifier.\"\n          },\n          \"code\": {\n            \"type\": \"string\",\n            \"description\": \"Short, stable diagnostic code (e.g. PACK_NOT_FOUND).\"\n          },\n          \"rule\": {\n            \"type\": \"string\",\n            \"description\": \"Rule identifier or namespace (e.g. pack.requires.packs).\"\n          },\n          \"severity\": {\n            \"type\": \"string\",\n            \"enum\": [\"error\", \"warn\", \"info\"]\n          },\n          \"message\": {\n            \"type\": \"string\"\n          },\n          \"location\": {\n            \"type\": \"object\",\n            \"description\": \"Optional structured location of the diagnostic.\",\n            \"additionalProperties\": true\n          },\n          \"hint\": {\n            \"type\": \"string\",\n            \"description\": \"Optional remediation hint.\"\n          },\n          \"details\": {\n            \"type\": \"object\",\n            \"additionalProperties\": true,\n            \"description\": \"Optional machine-readable details.\"\n          }\n        }\n      }\n    },\n    \"artifacts\": {\n      \"type\": \"array\",\n      \"description\": \"Artifacts produced by the command (paths, packs, commands).\",\n      \"items\": {\n        \"type\": \"object\",\n        \"additionalProperties\": true\n      }\n    }\n  }\n}\n</code></pre> <p>Step 4: Create <code>pantsagon/diagnostics/codes.yaml</code></p> <pre><code>version: 1\n\ncodes:\n  - code: PACK_NOT_FOUND\n    severity: error\n    rule: pack.catalog.fetch\n    message: Pack could not be found.\n    hint: Check pack id/version and configured pack sources.\n\n  - code: PACK_MISSING_REQUIRED\n    severity: error\n    rule: pack.requires.packs\n    message: Pack is missing required dependency packs.\n    hint: Add the required pack or choose a compatible feature set.\n\n  - code: COPIER_UNDECLARED_VARIABLE\n    severity: error\n    rule: pack.variables.copier_undeclared\n    message: Copier defines a variable that is not declared in pack.yaml.\n    hint: Declare it in pack.yaml.variables or remove it from copier.yml.\n\n  - code: COPIER_DEFAULT_MISMATCH\n    severity: warn\n    rule: pack.variables.default_mismatch\n    message: Copier default does not match pack.yaml default.\n    hint: Align defaults, or run in strict mode to fail builds.\n</code></pre> <p>Step 5: Commit</p> <pre><code>git add schemas/pack.schema.v1.json \\\n  schemas/repo-lock.schema.v1.json \\\n  schemas/result.schema.v1.json \\\n  pantsagon/diagnostics/codes.yaml\ngit commit -m \"docs: add schema and diagnostics sources\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-8-generate-reference-docs-from-sources","title":"Task 8: Generate reference docs from sources","text":"<p>Files: - Create: <code>docs/reference/pack.schema.v1.md</code> - Create: <code>docs/reference/repo-lock.schema.v1.md</code> - Create: <code>docs/reference/result.schema.v1.md</code> - Create: <code>docs/reference/diagnostic-codes.md</code></p> <p>Step 1: Run generators</p> <pre><code>python scripts/generate_schema_docs.py\npython scripts/generate_diagnostic_codes.py\n</code></pre> <p>Step 2: Spot-check headers</p> <p>Check each generated file begins with: - \u201cGenerated file. Do not edit directly.\u201d - \u201cRun: <code>python scripts/...</code>\u201d</p> <p>Step 3: Commit</p> <pre><code>git add docs/reference/pack.schema.v1.md \\\n  docs/reference/repo-lock.schema.v1.md \\\n  docs/reference/result.schema.v1.md \\\n  docs/reference/diagnostic-codes.md\ngit commit -m \"docs: generate reference docs\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-9-add-docs-github-actions-workflow","title":"Task 9: Add docs GitHub Actions workflow","text":"<p>Files: - Create: <code>.github/workflows/docs.yml</code></p> <p>Step 1: Create <code>.github/workflows/docs.yml</code></p> <pre><code>name: Docs\n\non:\n  pull_request:\n    paths:\n      - \"docs/**\"\n      - \"mkdocs.yml\"\n      - \".github/workflows/docs.yml\"\n      - \"schemas/**\"\n      - \"scripts/**\"\n      - \"pantsagon/diagnostics/codes.yaml\"\n  push:\n    branches: [\"main\"]\n    tags: [\"v*.*.*\"]\n    paths:\n      - \"docs/**\"\n      - \"mkdocs.yml\"\n      - \".github/workflows/docs.yml\"\n      - \"schemas/**\"\n      - \"scripts/**\"\n      - \"pantsagon/diagnostics/codes.yaml\"\n  workflow_dispatch: {}\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: docs-${{ github.ref }}\n  cancel-in-progress: true\n\njobs:\n  docs:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.12\"\n\n      - name: Install docs dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -r docs/requirements.txt\n\n      - name: Install generator dependencies\n        run: |\n          pip install pyyaml\n\n      - name: Generate reference docs (schemas + diagnostic codes)\n        run: |\n          python scripts/generate_schema_docs.py\n          python scripts/generate_diagnostic_codes.py\n\n      - name: Fail if generated docs are out of date\n        run: |\n          git diff --exit-code\n\n      - name: Build (strict)\n        run: |\n          mkdocs build --strict\n\n      - name: Configure git identity\n        run: |\n          git config user.name \"github-actions[bot]\"\n          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n\n      - name: Publish PR preview\n        if: github.event_name == 'pull_request'\n        env:\n          PR_NUM: ${{ github.event.number }}\n        run: |\n          mike deploy --push --branch gh-pages \"pr-${PR_NUM}\"\n\n      - name: Comment PR preview URL\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const pr = context.payload.pull_request.number;\n            const owner = context.repo.owner;\n            const repo = context.repo.repo;\n            const url = `https://${owner}.github.io/${repo}/pr-${pr}/`;\n            const body = [\n              \"Docs preview published:\",\n              \"\",\n              url\n            ].join(\"\\n\");\n            await github.rest.issues.createComment({\n              owner,\n              repo,\n              issue_number: pr,\n              body\n            });\n\n      - name: Publish dev docs (main)\n        if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/main'\n        run: |\n          mike deploy --push --branch gh-pages \"dev\"\n\n      - name: Publish release docs (tag) + update latest\n        if: github.event_name == 'push' &amp;&amp; startsWith(github.ref, 'refs/tags/v')\n        env:\n          TAG: ${{ github.ref_name }}\n        run: |\n          mike deploy --push --branch gh-pages --update-aliases \"${TAG}\" latest\n</code></pre> <p>Step 2: Commit</p> <pre><code>git add .github/workflows/docs.yml\ngit commit -m \"ci: add docs build and publish workflow\"\n</code></pre>"},{"location":"plans/2026-01-10-docs-system/#task-10-verification","title":"Task 10: Verification","text":"<p>Step 1: Run generators locally</p> <pre><code>python scripts/generate_schema_docs.py\npython scripts/generate_diagnostic_codes.py\n</code></pre> <p>Step 2: Build docs locally</p> <pre><code>mkdocs build --strict\n</code></pre> <p>Expected: <code>build</code> succeeds with no warnings or missing files.</p>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/","title":"Pants Monorepo Conversion Design","text":"<p>Date: 2026-01-10</p>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#goal","title":"Goal","text":"<p>Convert this repo into a Pants-managed monorepo with strict hexagonal layering, hard dependency boundaries, and contract-first guardrails, using Pants as the single control plane.</p>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#decisions-validated","title":"Decisions (validated)","text":"<ul> <li><code>pantsagon</code> becomes a service: <code>services/pantsagon/src/pantsagon/</code> with top-level layers: <code>domain/</code>, <code>ports/</code>, <code>application/</code>, <code>adapters/</code>, <code>entrypoints/</code>.</li> <li>CLI stays in <code>entrypoints/cli.py</code> and is executed via a packaging target at the service root.</li> <li><code>ports/</code> is a first-class layer (not nested under application).</li> <li><code>packs/</code> stays at repo root; <code>schemas/</code> move to <code>shared/contracts/schemas/</code>.</li> <li>Entry points are non-importable: only a packaging target may depend on them.</li> <li>Tag taxonomy includes an explicit <code>layer:ports</code>.</li> <li>No cross-service imports by default; add a <code>public_api</code> target only if needed later.</li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#target-layout","title":"Target Layout","text":"<pre><code>repo/\n  pants.toml\n  pyproject.toml\n  pyrightconfig.json\n  .ruff.toml\n\n  3rdparty/\n    python/\n      requirements.txt\n      BUILD\n\n  shared/\n    foundation/\n      src/...\n      tests/...\n      BUILD\n    adapters/\n      &lt;integration&gt;/\n        src/...\n        tests/...\n        BUILD\n    contracts/\n      schemas/\n        pack.schema.v1.json\n      BUILD\n\n  services/\n    pantsagon/\n      src/pantsagon/\n        domain/\n        ports/\n        application/\n        adapters/\n        entrypoints/\n      tests/\n      BUILD\n\n  packs/\n    core/\n    python/\n    openapi/\n    docker/\n\n  tools/\n    forbidden_imports/\n      forbidden_imports.yaml\n      src/...\n      tests/...\n      BUILD\n</code></pre>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#dependency-rules-hexagonal-enforcement","title":"Dependency Rules (Hexagonal Enforcement)","text":"<ul> <li>domain \u2192 domain + <code>shared/foundation</code></li> <li>ports \u2192 ports + domain + <code>shared/foundation</code></li> <li>application \u2192 application + ports + domain + <code>shared/foundation</code></li> <li>adapters \u2192 adapters + application + ports + domain + <code>shared/foundation</code> + allowlisted <code>shared/adapters</code> + 3rdparty</li> <li>entrypoints \u2192 entrypoints + adapters + application + ports + domain + <code>shared/foundation</code></li> </ul> <p>Service boundary: each layer target uses <code>__dependents_rules__</code> limited to <code>svc:pantsagon</code> tags, except entrypoints which are only depended on by a packaging target.</p>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#tags","title":"Tags","text":"<ul> <li><code>svc:pantsagon</code></li> <li><code>layer:domain|ports|application|adapters|entrypoints</code></li> <li><code>shared:foundation|adapters|contracts</code></li> <li><code>adapter:&lt;integration&gt;</code></li> <li>Optional: <code>domain:&lt;group&gt;</code>, <code>team:&lt;name&gt;</code></li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#build-snippet-patterns-key-example-entrypoints","title":"BUILD Snippet Patterns (key example: entrypoints)","text":"<pre><code># services/pantsagon/src/pantsagon/entrypoints/BUILD\n__dependents_rules__ = [\n  {\"address\": \"services/pantsagon:cli\"},\n]\n\npython_sources(\n  name=\"entrypoints\",\n  tags=[\"svc:pantsagon\", \"layer:entrypoints\"],\n  dependencies=[\n    \"//services/pantsagon/src/pantsagon/adapters:adapters\",\n    \"//services/pantsagon/src/pantsagon/application:application\",\n    \"//services/pantsagon/src/pantsagon/ports:ports\",\n    \"//services/pantsagon/src/pantsagon/domain:domain\",\n    \"//shared/foundation:lib\",\n  ],\n  __dependencies_rules__=[\n    {\"path\": \"services/pantsagon/src/pantsagon/entrypoints/**\"},\n    {\"path\": \"services/pantsagon/src/pantsagon/adapters/**\"},\n    {\"path\": \"services/pantsagon/src/pantsagon/application/**\"},\n    {\"path\": \"services/pantsagon/src/pantsagon/ports/**\"},\n    {\"path\": \"services/pantsagon/src/pantsagon/domain/**\"},\n    {\"path\": \"shared/foundation/src/**\"},\n    {\"path\": \"shared/adapters/**\"},\n    {\"path\": \"3rdparty/python/**\"},\n  ],\n)\n</code></pre> <pre><code># services/pantsagon/BUILD\npex_binary(\n  name=\"cli\",\n  entry_point=\"pantsagon.entrypoints.cli:app\",\n  dependencies=[\"//services/pantsagon/src/pantsagon/entrypoints:entrypoints\"],\n)\n</code></pre>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#pants-baseline","title":"Pants Baseline","text":"<ul> <li><code>pants.toml</code> per guide (Python, docker, ruff, pyright, pytest, openapi, visibility, terraform optional).</li> <li><code>[python-infer].unowned_dependency_behavior = \"error\"</code></li> <li><code>[visibility].enforce = true</code></li> <li>Single resolve at <code>3rdparty/python/python-default.lock</code>.</li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#contracts-assets","title":"Contracts &amp; Assets","text":"<ul> <li>JSON Schemas in <code>shared/contracts/schemas/</code> (validated with Pants/OpenAPI tooling if applicable).</li> <li>Packs remain at repo root as tool-owned assets (<code>packs/</code>).</li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#forbidden-imports-tooling","title":"Forbidden Imports Tooling","text":"<ul> <li>Extend the forbidden-import checker to include ports (deny frameworks/SDKs in <code>services/**/ports/**</code>).</li> <li>Keep domain/application/ports checks as developer-friendly errors; Pants rules remain authoritative.</li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#tests-policy","title":"Tests Policy","text":"<ul> <li>Domain tests: depend on domain only.</li> <li>Application tests: depend on application + ports + domain.</li> <li>Adapter tests: depend on adapters + ports + domain + application.</li> <li>Entry point tests: minimal; prefer integration tests.</li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#ci-commands","title":"CI Commands","text":"<ul> <li><code>pants tailor --check ::</code></li> <li><code>pants update-build-files --check ::</code></li> <li><code>pants lint check test ::</code></li> </ul>"},{"location":"plans/2026-01-10-pants-monorepo-conversion-design/#migration-summary","title":"Migration Summary","text":"<ul> <li>Move <code>pantsagon/</code> \u2192 <code>services/pantsagon/src/pantsagon/</code></li> <li>Keep layer subdirectories and add <code>ports/</code> as a top-level layer.</li> <li>Move <code>tests/</code> \u2192 <code>services/pantsagon/tests/</code></li> <li>Move <code>schemas/pack.schema.v1.json</code> \u2192 <code>shared/contracts/schemas/</code></li> <li>Keep <code>packs/</code> at repo root</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/","title":"Pantsagon CLI + Pack System Design","text":"<p>Goal: Ship Pantsagon v1 as a hexagonal, pack-based scaffolding CLI that generates enforced Pants hexagonal monorepos with contract-first (OpenAPI) and Docker packaging support.</p> <p>Architecture: Hexagonal core (domain/application) with ports/adapters. Packs are tool-agnostic via <code>pack.yaml</code>, rendered via Copier. CLI is a thin entrypoint; logic lives in application use-cases. <code>.pantsagon.toml</code> is the single source of truth for repo state.</p> <p>Tech Stack: Python, Typer (CLI), Copier (renderer), Pants.</p>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#scope-v1","title":"Scope (v1)","text":"<ul> <li>Commands: <code>init</code>, <code>add service</code>, <code>validate</code>.</li> <li>Packs: <code>core</code>, <code>python</code>, <code>openapi</code>, <code>docker</code>.</li> <li>Pack sources: bundled + local only (no git/registry in v1).</li> <li>Hooks: disabled by default; bundled packs may be allowed with explicit trust.</li> <li>No upgrade command in v1.</li> <li>Optional augmented-coding file creation (AGENTS/Claude/Gemini) during repo setup when explicitly requested.</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#repo-layout","title":"Repo Layout","text":"<pre><code>pantsagon/\n  pantsagon/\n    domain/\n    application/\n    ports/\n    adapters/\n      pack_catalog/\n      renderer/\n      workspace/\n      policy/\n      command/\n    entrypoints/\n  packs/\n    _shared/\n      templates/\n    core/\n    python/\n    openapi/\n    docker/\n  schemas/\n    pack.schema.v1.json\n    lock.schema.v1.json\n  tests/\n  docs/\n  pyproject.toml\n  README.md\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#domain-model","title":"Domain Model","text":"<ul> <li>Blueprint: user intent (repo name, languages, services, features).</li> <li>PackRef: <code>{id, version, source, location?, git_ref?, commit?, digest?, subdir?}</code>.</li> <li>PackDigest: optional hash for content-addressing (v1 unused, but modeled).</li> <li>PackSelection: ordered list of PackRef + resolved dependency graph.</li> <li>RenderPlan: deterministic plan of outputs and a patch (create/modify/delete).</li> <li>RepoLock: representation of <code>.pantsagon.toml</code> (single source of truth).</li> <li>Diagnostic: structured error/warn/info with <code>code</code>, <code>rule</code>, <code>id</code>, <code>severity</code>, <code>message</code>, <code>location</code>, <code>hint</code>, <code>details</code>.</li> <li>Result[T]: <code>value?</code>, <code>diagnostics[]</code>, <code>artifacts[]</code>, <code>exit_code</code>.</li> <li>Location union: Pack(id,path), File(path,line,col), Path(path), Command(name).</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#pantsagontoml-structure","title":"<code>.pantsagon.toml</code> Structure","text":"<pre><code>[tool]\nname = \"pantsagon\"\nversion = \"1.0.0\"\n\n[settings]\nrenderer = \"copier\"\nstrict = false\nstrict_manifest = true\nallow_hooks = false\n\n[selection]\nlanguages = [\"python\"]\nfeatures = [\"openapi\", \"docker\"]\nservices = [\"monitors\", \"governance\"]\naugmented_coding = \"agents\" # or \"claude\" | \"gemini\" | \"none\"\n\n[[resolved.packs]]\nid = \"pantsagon.core\"\nversion = \"1.0.0\"\nsource = \"bundled\"\n\n[resolved.answers]\npython_min = \"3.12\"\npython_max = \"3.14\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#use-case-flows","title":"Use-Case Flows","text":""},{"location":"plans/2026-01-10-pantsagon-cli-design/#init","title":"<code>init</code>","text":"<ol> <li>Parse inputs \u2192 <code>Blueprint</code>.</li> <li>Resolve <code>PackSelection</code> (validate compatibility, required/conflicts).</li> <li>Validate pack schema (<code>pack.yaml</code>) + manifest\u2194Copier cross-check.</li> <li>Build deterministic <code>RenderPlan</code> (patch-oriented).</li> <li>Workspace transaction: render into staging dir, write <code>.pantsagon.toml</code> in staging, then atomic commit.</li> <li>Run repo policy checks.</li> <li>Optional execution (<code>pants tailor --check</code>, <code>pants lint/check/test</code>) if explicitly requested.</li> </ol>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#add-service","title":"<code>add service</code>","text":"<ul> <li>Validate repo + load <code>.pantsagon.toml</code>.</li> <li>Enforce naming rules (kebab-case, reserved names forbidden, deterministic package name mapping).</li> <li>Idempotent by default: fail if service exists unless <code>--overwrite</code> (future).</li> <li>Render only service-scoped <code>RenderPlan</code> into staging and commit atomically.</li> <li>Update <code>.pantsagon.toml</code>.</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#validate","title":"<code>validate</code>","text":"<ul> <li>Validate schema, compatibility, pack selection, and repo invariants.</li> <li>Detect lock drift: recompute expected paths from lock and check existence.</li> <li>Optional exec validation with <code>--exec</code>.</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#validate_pack-internal-use-case","title":"<code>validate_pack</code> (internal use-case)","text":"<ul> <li>Schema validation</li> <li>Manifest\u2194Copier cross-check</li> <li>Render smoke-test into temp dir</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#ports-contracts","title":"Ports (Contracts)","text":"<ul> <li>PackCatalogPort: list/find/fetch packs (by PackRef).</li> <li>RendererPort: render <code>RenderRequest</code> \u2192 <code>RenderOutcome</code> (renderer-agnostic).</li> <li>WorkspacePort: begin transaction, apply patch, commit/rollback atomically.</li> <li>PolicyEnginePort: validate packs + repo invariants, return Diagnostics.</li> <li>CommandRunnerPort: execute Pants commands (optional, explicit).</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#errors-and-results","title":"Errors and Results","text":"<ul> <li>Expected validation failures return <code>Result</code> with diagnostics (exit code 2).</li> <li>Execution/IO failures raise typed <code>AdapterError</code> (exit code 3).</li> <li>Exit code precedence: exec error \u2192 3, else validation error \u2192 2, else 0; unexpected \u2192 4.</li> </ul> <p>AdapterError taxonomy (stable): - PackFetchError, PackReadError, PackParseError - RendererTemplateError, RendererExecutionError - WorkspaceTransactionError, WorkspaceCommitError - CommandNotFound, CommandFailed, CommandTimeout</p>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#packs","title":"Packs","text":"<ul> <li>Pack format: <code>pack.yaml</code> (authoritative) + <code>copier.yml</code> (renderer config) + <code>templates/</code>.</li> <li><code>pack.yaml</code> schema is validated by <code>schemas/pack.schema.v1.json</code>.</li> <li>Cross-check rules (strict by default):</li> <li>all manifest variables must exist in Copier</li> <li>no undeclared Copier variables unless <code>extra_variables=true</code></li> <li>default mismatch = warning (upgraded to error in <code>--strict</code>)</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#trust-model","title":"Trust Model","text":"<ul> <li>Trust is split between content and hook execution.</li> <li>Defaults: allow content from bundled/local; allow hooks from bundled only.</li> <li><code>--allow-hooks</code> overrides (explicit).</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#cli-contract-v1","title":"CLI Contract (v1)","text":"<ul> <li><code>pantsagon init &lt;repo&gt;</code></li> <li><code>--lang python</code> (required)</li> <li><code>--services a,b</code></li> <li><code>--feature openapi --feature docker</code> (alias <code>--with</code>)</li> <li><code>--augmented-coding {agents|claude|gemini|none}</code> (creates AGENTS.md or equivalent)</li> <li><code>--non-interactive</code></li> <li><code>--strict</code></li> <li><code>--renderer copier</code></li> <li><code>--json</code></li> <li><code>pantsagon add service &lt;name&gt;</code></li> <li><code>--lang python</code></li> <li><code>--feature openapi --feature docker</code></li> <li><code>--strict</code></li> <li><code>--json</code></li> <li><code>pantsagon validate</code></li> <li><code>--exec</code></li> <li><code>--strict</code></li> <li><code>--json</code></li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#json-output","title":"JSON Output","text":"<ul> <li>Always include <code>result_schema_version</code>, <code>timestamp</code>, <code>command</code>, <code>args</code>, <code>exit_code</code>.</li> <li><code>Diagnostic</code> is stable with structured <code>location</code> and deterministic <code>id</code>.</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Deterministic mode via <code>--deterministic</code> or <code>PANTSAGON_DETERMINISTIC=1</code>.</li> <li>Unit tests: domain invariants, pack resolution, naming rules, exit-code precedence.</li> <li>Adapter tests: Copier failure mapping, workspace commit/rollback, policy checks.</li> <li>Pack tests (gated on any change under <code>packs/**</code>):   1) schema validation   2) manifest\u2194Copier cross-check   3) render smoke-test</li> <li>E2E tests: verify key files/paths and invariants (avoid full-tree diffs by default).</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#versioning-compatibility","title":"Versioning &amp; Compatibility","text":"<ul> <li>Tool and packs use SemVer independently.</li> <li>Packs declare compatibility ranges in <code>pack.yaml</code>.</li> <li>Bundled pack compatibility is verified in CI.</li> <li>Pack SemVer rules:</li> <li>Patch: docs/typos, non-functional tweaks</li> <li>Minor: additive variables with defaults, additive files</li> <li>Major: variable removals, path renames, behavior changes</li> <li>Schema versions are file-based (<code>pack.schema.v1.json</code>).</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-design/#implementation-notes-v1","title":"Implementation Notes (v1)","text":"<ul> <li>Bundled packs: core/python/openapi/docker.</li> <li>Local pack catalog adapter reads <code>pack.yaml</code> from path.</li> <li>Renderer adapter uses Copier; no Copier concepts leak into ports.</li> <li>Workspace adapter provides atomic staging + commit.</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/","title":"Pantsagon CLI Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Implement Pantsagon v1 as a hexagonal, pack\u2011based scaffolding CLI (Typer + Copier) that generates enforced Pants hexagonal monorepos with OpenAPI + Docker packs.</p> <p>Architecture: Hexagonal core (domain/application) with ports/adapters. Packs are tool\u2011agnostic via <code>pack.yaml</code> validated by schema. Copier renders templates. <code>.pantsagon.toml</code> is the single source of truth for repo state. CLI is a thin adapter.</p> <p>Tech Stack: Python 3.12, Typer, Copier, PyYAML, jsonschema, pytest.</p>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-1-project-skeleton-tooling-bootstrap","title":"Task 1: Project skeleton + tooling bootstrap","text":"<p>Files: - Create: <code>pyproject.toml</code> - Create: <code>pantsagon/__init__.py</code> - Create: <code>pantsagon/domain/__init__.py</code> - Create: <code>pantsagon/application/__init__.py</code> - Create: <code>pantsagon/ports/__init__.py</code> - Create: <code>pantsagon/adapters/__init__.py</code> - Create: <code>pantsagon/entrypoints/__init__.py</code> - Create: <code>tests/__init__.py</code></p> <p>Step 1: Write failing test (package import smoke)</p> <pre><code># tests/test_imports.py\n\ndef test_imports():\n    import pantsagon\n    assert pantsagon.__package__ == \"pantsagon\"\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/test_imports.py -q</code> Expected: FAIL (module not found)</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/__init__.py\n__all__ = [\"__version__\"]\n__version__ = \"0.1.0\"\n</code></pre> <pre><code># pyproject.toml\n[build-system]\nrequires = [\"hatchling&gt;=1.21.0\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"pantsagon\"\nversion = \"0.1.0\"\ndescription = \"Hexagonal monorepos, generated with enforcement.\"\nrequires-python = \"&gt;=3.12\"\ndependencies = [\n  \"typer&gt;=0.12\",\n  \"copier&gt;=9.0\",\n  \"pyyaml&gt;=6.0\",\n  \"jsonschema&gt;=4.22\",\n  \"tomli-w&gt;=1.0\",\n  \"rich&gt;=13.7\",\n]\n\n[project.optional-dependencies]\ndev = [\"pytest&gt;=8.0\", \"pytest-cov&gt;=5.0\"]\n\n[project.scripts]\npantsagon = \"pantsagon.entrypoints.cli:app\"\n\n[tool.pytest.ini_options]\naddopts = \"-q\"\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/test_imports.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pyproject.toml pantsagon/__init__.py tests/test_imports.py\n\ngit commit -m \"chore: bootstrap python package\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-2-domain-primitives-diagnostic-result-location-packref","title":"Task 2: Domain primitives (Diagnostic, Result, Location, PackRef)","text":"<p>Files: - Create: <code>pantsagon/domain/diagnostics.py</code> - Create: <code>pantsagon/domain/result.py</code> - Create: <code>pantsagon/domain/pack.py</code> - Test: <code>tests/domain/test_diagnostics.py</code> - Test: <code>tests/domain/test_result.py</code> - Test: <code>tests/domain/test_packref.py</code></p> <p>Step 1: Write failing tests</p> <pre><code># tests/domain/test_diagnostics.py\nfrom pantsagon.domain.diagnostics import Diagnostic, Severity, FileLocation\n\ndef test_diagnostic_id_is_deterministic():\n    d1 = Diagnostic(code=\"X\", rule=\"r\", severity=Severity.ERROR, message=\"m\", location=FileLocation(\"a.txt\", 1, 2))\n    d2 = Diagnostic(code=\"X\", rule=\"r\", severity=Severity.ERROR, message=\"m\", location=FileLocation(\"a.txt\", 1, 2))\n    assert d1.id == d2.id\n</code></pre> <pre><code># tests/domain/test_result.py\nfrom pantsagon.domain.result import Result\nfrom pantsagon.domain.diagnostics import Diagnostic, Severity\n\ndef test_exit_code_precedence_exec_over_validation():\n    r = Result(diagnostics=[\n        Diagnostic(code=\"VAL\", rule=\"r\", severity=Severity.ERROR, message=\"v\"),\n        Diagnostic(code=\"EXEC\", rule=\"r\", severity=Severity.ERROR, message=\"e\", is_execution=True),\n    ])\n    assert r.exit_code == 3\n</code></pre> <pre><code># tests/domain/test_packref.py\nfrom pantsagon.domain.pack import PackRef\n\ndef test_packref_supports_future_fields():\n    ref = PackRef(id=\"pantsagon.core\", version=\"1.0.0\", source=\"bundled\", location=None, git_ref=None, commit=None, digest=None, subdir=None)\n    assert ref.source == \"bundled\"\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>pytest tests/domain/test_diagnostics.py tests/domain/test_result.py tests/domain/test_packref.py -q</code> Expected: FAIL (imports missing)</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/domain/diagnostics.py\nfrom __future__ import annotations\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nimport hashlib\nfrom typing import Any\n\nclass Severity(str, Enum):\n    ERROR = \"error\"\n    WARN = \"warn\"\n    INFO = \"info\"\n\n@dataclass(frozen=True)\nclass Location:\n    kind: str\n\n@dataclass(frozen=True)\nclass FileLocation(Location):\n    path: str\n    line: int | None = None\n    col: int | None = None\n    def __init__(self, path: str, line: int | None = None, col: int | None = None):\n        object.__setattr__(self, \"kind\", \"file\")\n        object.__setattr__(self, \"path\", path)\n        object.__setattr__(self, \"line\", line)\n        object.__setattr__(self, \"col\", col)\n\n@dataclass(frozen=True)\nclass Diagnostic:\n    code: str\n    rule: str\n    severity: Severity\n    message: str\n    location: Location | None = None\n    hint: str | None = None\n    details: dict[str, Any] | None = None\n    is_execution: bool = False\n    id: str = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        raw = f\"{self.code}|{self.rule}|{self.severity}|{self.message}|{self.location}\"\n        object.__setattr__(self, \"id\", hashlib.sha256(raw.encode()).hexdigest()[:12])\n</code></pre> <pre><code># pantsagon/domain/result.py\nfrom dataclasses import dataclass, field\nfrom typing import Generic, TypeVar\nfrom pantsagon.domain.diagnostics import Diagnostic, Severity\n\nT = TypeVar(\"T\")\n\n@dataclass\nclass Result(Generic[T]):\n    value: T | None = None\n    diagnostics: list[Diagnostic] = field(default_factory=list)\n    artifacts: list[dict] = field(default_factory=list)\n\n    @property\n    def exit_code(self) -&gt; int:\n        has_exec = any(d.is_execution and d.severity == Severity.ERROR for d in self.diagnostics)\n        has_val = any((not d.is_execution) and d.severity == Severity.ERROR for d in self.diagnostics)\n        if has_exec:\n            return 3\n        if has_val:\n            return 2\n        return 0\n</code></pre> <pre><code># pantsagon/domain/pack.py\nfrom dataclasses import dataclass\nfrom typing import Literal\n\nPackSource = Literal[\"bundled\", \"local\", \"git\", \"registry\"]\n\n@dataclass(frozen=True)\nclass PackRef:\n    id: str\n    version: str\n    source: PackSource\n    location: str | None = None\n    git_ref: str | None = None\n    commit: str | None = None\n    digest: str | None = None\n    subdir: str | None = None\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/domain/test_diagnostics.py tests/domain/test_result.py tests/domain/test_packref.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/domain tests/domain\ngit commit -m \"feat: add domain primitives\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-3-pack-schema-manifest-parsing-copier-cross-check","title":"Task 3: Pack schema + manifest parsing + Copier cross-check","text":"<p>Files: - Create: <code>schemas/pack.schema.v1.json</code> - Create: <code>pantsagon/application/pack_validation.py</code> - Create: <code>pantsagon/adapters/policy/pack_validator.py</code> - Test: <code>tests/pack/test_pack_schema.py</code> - Test: <code>tests/pack/test_copier_crosscheck.py</code> - Fixture: <code>tests/fixtures/packs/minimal/pack.yaml</code> - Fixture: <code>tests/fixtures/packs/minimal/copier.yml</code></p> <p>Step 1: Write failing tests</p> <pre><code># tests/pack/test_pack_schema.py\nfrom pantsagon.application.pack_validation import validate_pack\n\n\ndef test_manifest_schema_validation(tmp_path):\n    pack = tmp_path / \"pack\"\n    pack.mkdir()\n    (pack / \"pack.yaml\").write_text(\"id: x\\nversion: 1.0.0\\n\")\n    (pack / \"copier.yml\").write_text(\"_min_copier_version: '9.0'\\n\")\n    result = validate_pack(pack)\n    assert any(d.code == \"PACK_SCHEMA_INVALID\" for d in result.diagnostics)\n</code></pre> <pre><code># tests/pack/test_copier_crosscheck.py\nfrom pantsagon.application.pack_validation import validate_pack\n\n\ndef test_copier_crosscheck_detects_undeclared_var(tmp_path):\n    pack = tmp_path / \"pack\"\n    pack.mkdir()\n    (pack / \"pack.yaml\").write_text(\"id: x\\nversion: 1.0.0\\nvariables: [{name: service_name, type: string}]\\n\")\n    (pack / \"copier.yml\").write_text(\"service_name: {type: str}\\nextra_var: {type: str}\\n\")\n    result = validate_pack(pack)\n    assert any(d.code == \"PACK_COPIER_UNDECLARED_VAR\" for d in result.diagnostics)\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>pytest tests/pack/test_pack_schema.py tests/pack/test_copier_crosscheck.py -q</code> Expected: FAIL (missing validator)</p> <p>Step 3: Write minimal implementation</p> <pre><code>// schemas/pack.schema.v1.json\n{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"required\": [\"id\", \"version\"],\n  \"properties\": {\n    \"id\": {\"type\": \"string\"},\n    \"version\": {\"type\": \"string\"},\n    \"description\": {\"type\": \"string\"},\n    \"variables\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"name\", \"type\"],\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n          \"type\": {\"type\": \"string\"},\n          \"default\": {}\n        }\n      }\n    }\n  }\n}\n</code></pre> <pre><code># pantsagon/adapters/policy/pack_validator.py\nfrom __future__ import annotations\nimport json\nfrom pathlib import Path\nimport yaml\nimport jsonschema\nfrom pantsagon.domain.diagnostics import Diagnostic, Severity\n\nSCHEMA_PATH = Path(__file__).resolve().parents[2] / \"schemas\" / \"pack.schema.v1.json\"\n\n\ndef load_manifest(pack_dir: Path) -&gt; dict:\n    return yaml.safe_load((pack_dir / \"pack.yaml\").read_text()) or {}\n\n\ndef load_copier_vars(pack_dir: Path) -&gt; set[str]:\n    data = yaml.safe_load((pack_dir / \"copier.yml\").read_text()) or {}\n    return {k for k in data.keys() if not k.startswith(\"_\")}\n\n\ndef validate_manifest_schema(manifest: dict) -&gt; list[Diagnostic]:\n    schema = json.loads(SCHEMA_PATH.read_text())\n    try:\n        jsonschema.validate(manifest, schema)\n        return []\n    except jsonschema.ValidationError as e:\n        return [Diagnostic(code=\"PACK_SCHEMA_INVALID\", rule=\"pack.schema\", severity=Severity.ERROR, message=str(e))]\n\n\ndef crosscheck_variables(manifest: dict, copier_vars: set[str]) -&gt; list[Diagnostic]:\n    declared = {v[\"name\"] for v in manifest.get(\"variables\", [])}\n    diagnostics: list[Diagnostic] = []\n    undeclared = copier_vars - declared\n    for var in sorted(undeclared):\n        diagnostics.append(Diagnostic(code=\"PACK_COPIER_UNDECLARED_VAR\", rule=\"pack.copier\", severity=Severity.ERROR, message=f\"Undeclared variable: {var}\"))\n    return diagnostics\n</code></pre> <pre><code># pantsagon/application/pack_validation.py\nfrom pathlib import Path\nfrom pantsagon.domain.result import Result\nfrom pantsagon.adapters.policy.pack_validator import load_manifest, load_copier_vars, validate_manifest_schema, crosscheck_variables\n\n\ndef validate_pack(pack_path: Path) -&gt; Result[dict]:\n    manifest = load_manifest(pack_path)\n    copier_vars = load_copier_vars(pack_path)\n    diags = []\n    diags.extend(validate_manifest_schema(manifest))\n    diags.extend(crosscheck_variables(manifest, copier_vars))\n    return Result(value=manifest, diagnostics=diags)\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/pack/test_pack_schema.py tests/pack/test_copier_crosscheck.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add schemas pantsagon/application/pack_validation.py pantsagon/adapters/policy/pack_validator.py tests/pack\ngit commit -m \"feat: add pack schema validation\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-4-ports-adaptererror-taxonomy","title":"Task 4: Ports + AdapterError taxonomy","text":"<p>Files: - Create: <code>pantsagon/ports/pack_catalog.py</code> - Create: <code>pantsagon/ports/renderer.py</code> - Create: <code>pantsagon/ports/workspace.py</code> - Create: <code>pantsagon/ports/policy_engine.py</code> - Create: <code>pantsagon/ports/command_runner.py</code> - Create: <code>pantsagon/adapters/errors.py</code> - Test: <code>tests/adapters/test_adapter_errors.py</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/adapters/test_adapter_errors.py\nfrom pantsagon.adapters.errors import RendererExecutionError\n\ndef test_adapter_error_has_message_and_details():\n    err = RendererExecutionError(\"boom\", details={\"x\": 1})\n    assert \"boom\" in str(err)\n    assert err.details[\"x\"] == 1\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/adapters/test_adapter_errors.py -q</code> Expected: FAIL (missing class)</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/adapters/errors.py\nfrom dataclasses import dataclass\nfrom typing import Any\n\n@dataclass\nclass AdapterError(Exception):\n    message: str\n    details: dict[str, Any] | None = None\n    hint: str | None = None\n    cause: Exception | None = None\n\n    def __str__(self) -&gt; str:\n        return self.message\n\nclass PackFetchError(AdapterError):\n    pass\n\nclass PackReadError(AdapterError):\n    pass\n\nclass PackParseError(AdapterError):\n    pass\n\nclass RendererTemplateError(AdapterError):\n    pass\n\nclass RendererExecutionError(AdapterError):\n    pass\n\nclass WorkspaceTransactionError(AdapterError):\n    pass\n\nclass WorkspaceCommitError(AdapterError):\n    pass\n\nclass CommandNotFound(AdapterError):\n    pass\n\nclass CommandFailed(AdapterError):\n    pass\n\nclass CommandTimeout(AdapterError):\n    pass\n</code></pre> <pre><code># pantsagon/ports/renderer.py\nfrom typing import Protocol\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom pantsagon.domain.pack import PackRef\n\n@dataclass\nclass RenderRequest:\n    pack: PackRef\n    pack_path: Path\n    staging_dir: Path\n    answers: dict\n    allow_hooks: bool\n\n@dataclass\nclass RenderOutcome:\n    rendered_paths: list[Path]\n    warnings: list[str]\n\nclass RendererPort(Protocol):\n    def render(self, request: RenderRequest) -&gt; RenderOutcome: ...\n</code></pre> <p>(Implement similar Protocols for pack_catalog, workspace, policy_engine, command_runner.)</p> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/adapters/test_adapter_errors.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/ports pantsagon/adapters/errors.py tests/adapters/test_adapter_errors.py\n\ngit commit -m \"feat: add ports and adapter error taxonomy\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-5-pack-catalog-adapters-bundled-local","title":"Task 5: Pack catalog adapters (bundled + local)","text":"<p>Files: - Create: <code>pantsagon/adapters/pack_catalog/bundled.py</code> - Create: <code>pantsagon/adapters/pack_catalog/local.py</code> - Test: <code>tests/adapters/test_pack_catalog.py</code> - Fixture: <code>tests/fixtures/packs/minimal/pack.yaml</code> - Fixture: <code>tests/fixtures/packs/minimal/copier.yml</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/adapters/test_pack_catalog.py\nfrom pathlib import Path\nfrom pantsagon.adapters.pack_catalog.local import LocalPackCatalog\n\n\ndef test_local_pack_catalog_loads_manifest(tmp_path):\n    pack = tmp_path / \"pack\"\n    pack.mkdir()\n    (pack / \"pack.yaml\").write_text(\"id: x\\nversion: 1.0.0\\n\")\n    (pack / \"copier.yml\").write_text(\"_min_copier_version: '9.0'\\n\")\n    catalog = LocalPackCatalog()\n    manifest = catalog.load_manifest(pack)\n    assert manifest[\"id\"] == \"x\"\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/adapters/test_pack_catalog.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/adapters/pack_catalog/local.py\nfrom pathlib import Path\nimport yaml\n\nclass LocalPackCatalog:\n    def load_manifest(self, pack_dir: Path) -&gt; dict:\n        return yaml.safe_load((pack_dir / \"pack.yaml\").read_text()) or {}\n</code></pre> <pre><code># pantsagon/adapters/pack_catalog/bundled.py\nfrom pathlib import Path\n\nclass BundledPackCatalog:\n    def __init__(self, root: Path) -&gt; None:\n        self.root = root\n\n    def get_pack_path(self, pack_id: str) -&gt; Path:\n        return self.root / pack_id.split(\".\")[-1]\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/adapters/test_pack_catalog.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/adapters/pack_catalog tests/adapters/test_pack_catalog.py\n\ngit commit -m \"feat: add pack catalog adapters\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-6-renderer-adapter-copier","title":"Task 6: Renderer adapter (Copier)","text":"<p>Files: - Create: <code>pantsagon/adapters/renderer/copier_renderer.py</code> - Test: <code>tests/adapters/test_renderer_copier.py</code> - Fixture: <code>tests/fixtures/packs/minimal/templates/README.md.jinja</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/adapters/test_renderer_copier.py\nfrom pathlib import Path\nfrom pantsagon.adapters.renderer.copier_renderer import CopierRenderer\nfrom pantsagon.domain.pack import PackRef\nfrom pantsagon.ports.renderer import RenderRequest\n\n\ndef test_copier_renders_template(tmp_path):\n    pack = tmp_path / \"pack\"\n    (pack / \"templates\").mkdir(parents=True)\n    (pack / \"pack.yaml\").write_text(\"id: x\\nversion: 1.0.0\\nvariables: [{name: name, type: string}]\\n\")\n    (pack / \"copier.yml\").write_text(\"name: {type: str}\\n_templates_suffix: '.jinja'\\n_subdirectory: 'templates'\\n\")\n    (pack / \"templates\" / \"README.md.jinja\").write_text(\"Hello {{ name }}\")\n    out = tmp_path / \"out\"\n    out.mkdir()\n    req = RenderRequest(pack=PackRef(id=\"x\", version=\"1.0.0\", source=\"local\"), pack_path=pack, staging_dir=out, answers={\"name\": \"World\"}, allow_hooks=False)\n    result = CopierRenderer().render(req)\n    assert (out / \"README.md\").read_text() == \"Hello World\"\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/adapters/test_renderer_copier.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/adapters/renderer/copier_renderer.py\nfrom copier import run_copy\nfrom pantsagon.adapters.errors import RendererExecutionError\nfrom pantsagon.ports.renderer import RenderRequest, RenderOutcome\n\nclass CopierRenderer:\n    def render(self, request: RenderRequest) -&gt; RenderOutcome:\n        try:\n            run_copy(\n                str(request.pack_path),\n                str(request.staging_dir),\n                data=request.answers,\n                unsafe=request.allow_hooks,\n            )\n        except Exception as e:  # Copier raises various exceptions\n            raise RendererExecutionError(\"Copier failed\", details={\"pack\": request.pack.id}, cause=e)\n        return RenderOutcome(rendered_paths=[request.staging_dir], warnings=[])\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/adapters/test_renderer_copier.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/adapters/renderer tests/adapters/test_renderer_copier.py\n\ngit commit -m \"feat: add copier renderer adapter\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-7-workspace-adapter-with-staging-atomic-commit-init-add-service","title":"Task 7: Workspace adapter with staging + atomic commit (init + add service)","text":"<p>Files: - Create: <code>pantsagon/adapters/workspace/filesystem.py</code> - Test: <code>tests/adapters/test_workspace.py</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/adapters/test_workspace.py\nfrom pathlib import Path\nfrom pantsagon.adapters.workspace.filesystem import FilesystemWorkspace\n\n\ndef test_workspace_commit_writes_files(tmp_path):\n    ws = FilesystemWorkspace(tmp_path)\n    stage = ws.begin_transaction()\n    (stage / \"hello.txt\").write_text(\"hi\")\n    ws.commit(stage)\n    assert (tmp_path / \"hello.txt\").read_text() == \"hi\"\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/adapters/test_workspace.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/adapters/workspace/filesystem.py\nfrom pathlib import Path\nimport shutil\nimport tempfile\nfrom pantsagon.adapters.errors import WorkspaceCommitError\n\nclass FilesystemWorkspace:\n    def __init__(self, root: Path) -&gt; None:\n        self.root = root\n\n    def begin_transaction(self) -&gt; Path:\n        return Path(tempfile.mkdtemp(prefix=\"pantsagon-stage-\", dir=self.root.parent))\n\n    def commit(self, stage: Path) -&gt; None:\n        try:\n            for path in stage.rglob(\"*\"):\n                rel = path.relative_to(stage)\n                dest = self.root / rel\n                if path.is_dir():\n                    dest.mkdir(parents=True, exist_ok=True)\n                else:\n                    dest.parent.mkdir(parents=True, exist_ok=True)\n                    shutil.copy2(path, dest)\n        except Exception as e:\n            raise WorkspaceCommitError(\"Workspace commit failed\", cause=e)\n        finally:\n            shutil.rmtree(stage, ignore_errors=True)\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/adapters/test_workspace.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/adapters/workspace tests/adapters/test_workspace.py\n\ngit commit -m \"feat: add filesystem workspace adapter\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-8-application-use-cases-init-add-service-validate","title":"Task 8: Application use-cases (init / add service / validate)","text":"<p>Files: - Create: <code>pantsagon/application/init_repo.py</code> - Create: <code>pantsagon/application/add_service.py</code> - Create: <code>pantsagon/application/validate_repo.py</code> - Test: <code>tests/application/test_init_repo.py</code> - Test: <code>tests/application/test_add_service.py</code></p> <p>Step 1: Write failing tests</p> <pre><code># tests/application/test_init_repo.py\nfrom pathlib import Path\nfrom pantsagon.application.init_repo import init_repo\n\n\ndef test_init_repo_writes_lock(tmp_path, monkeypatch):\n    result = init_repo(repo_path=tmp_path, languages=[\"python\"], services=[\"monitors\"], features=[\"openapi\"], renderer=\"copier\")\n    assert (tmp_path / \".pantsagon.toml\").exists()\n</code></pre> <pre><code># tests/application/test_add_service.py\nfrom pathlib import Path\nfrom pantsagon.application.add_service import add_service\n\n\ndef test_add_service_fails_on_existing(tmp_path):\n    (tmp_path / \".pantsagon.toml\").write_text(\"[tool]\\nname='pantsagon'\\nversion='0.1.0'\\n\")\n    svc_dir = tmp_path / \"services\" / \"foo\"\n    svc_dir.mkdir(parents=True)\n    result = add_service(repo_path=tmp_path, name=\"foo\", lang=\"python\")\n    assert any(d.code == \"SERVICE_EXISTS\" for d in result.diagnostics)\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>pytest tests/application/test_init_repo.py tests/application/test_add_service.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/application/init_repo.py\nfrom pathlib import Path\nfrom pantsagon.domain.result import Result\nfrom pantsagon.domain.diagnostics import Diagnostic, Severity\nimport tomli_w\n\n\ndef init_repo(repo_path: Path, languages: list[str], services: list[str], features: list[str], renderer: str) -&gt; Result[None]:\n    lock = {\n        \"tool\": {\"name\": \"pantsagon\", \"version\": \"0.1.0\"},\n        \"settings\": {\"renderer\": renderer, \"strict\": False, \"strict_manifest\": True, \"allow_hooks\": False},\n        \"selection\": {\"languages\": languages, \"features\": features, \"services\": services, \"augmented_coding\": \"none\"},\n        \"resolved\": {\"packs\": [], \"answers\": {}},\n    }\n    (repo_path / \".pantsagon.toml\").write_text(tomli_w.dumps(lock))\n    return Result()\n</code></pre> <pre><code># pantsagon/application/add_service.py\nfrom pathlib import Path\nfrom pantsagon.domain.result import Result\nfrom pantsagon.domain.diagnostics import Diagnostic, Severity\n\n\ndef add_service(repo_path: Path, name: str, lang: str) -&gt; Result[None]:\n    svc_dir = repo_path / \"services\" / name\n    if svc_dir.exists():\n        return Result(diagnostics=[Diagnostic(code=\"SERVICE_EXISTS\", rule=\"service.name\", severity=Severity.ERROR, message=\"Service already exists\")])\n    return Result()\n</code></pre> <pre><code># pantsagon/application/validate_repo.py\nfrom pathlib import Path\nfrom pantsagon.domain.result import Result\n\n\ndef validate_repo(repo_path: Path) -&gt; Result[None]:\n    return Result()\n</code></pre> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/application/test_init_repo.py tests/application/test_add_service.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/application tests/application\n\ngit commit -m \"feat: add minimal use-case scaffolds\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-9-cli-entrypoint-with-typer-json-output","title":"Task 9: CLI entrypoint with Typer + JSON output","text":"<p>Files: - Create: <code>pantsagon/entrypoints/cli.py</code> - Test: <code>tests/entrypoints/test_cli_init.py</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/entrypoints/test_cli_init.py\nfrom typer.testing import CliRunner\nfrom pantsagon.entrypoints.cli import app\n\n\ndef test_cli_init_writes_lock(tmp_path):\n    runner = CliRunner()\n    result = runner.invoke(app, [\"init\", str(tmp_path), \"--lang\", \"python\", \"--services\", \"monitors\", \"--feature\", \"openapi\"])\n    assert result.exit_code == 0\n    assert (tmp_path / \".pantsagon.toml\").exists()\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/entrypoints/test_cli_init.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <pre><code># pantsagon/entrypoints/cli.py\nimport typer\nfrom pathlib import Path\nfrom pantsagon.application.init_repo import init_repo\n\napp = typer.Typer(add_completion=False)\n\n@app.command()\ndef init(repo: Path, lang: str = typer.Option(...), services: str = \"\", feature: list[str] = typer.Option(None)):\n    features = feature or []\n    svc_list = [s for s in services.split(\",\") if s]\n    init_repo(repo, [lang], svc_list, features, renderer=\"copier\")\n    raise typer.Exit(0)\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/entrypoints/test_cli_init.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/entrypoints tests/entrypoints\n\ngit commit -m \"feat: add minimal typer cli\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-10-bundled-packs-corepythonopenapidocker-pack-tests","title":"Task 10: Bundled packs (core/python/openapi/docker) + pack tests","text":"<p>Files: - Create: <code>packs/core/pack.yaml</code>, <code>packs/core/copier.yml</code>, <code>packs/core/templates/...</code> - Create: <code>packs/python/pack.yaml</code>, <code>packs/python/copier.yml</code>, <code>packs/python/templates/...</code> - Create: <code>packs/openapi/pack.yaml</code>, <code>packs/openapi/copier.yml</code>, <code>packs/openapi/templates/...</code> - Create: <code>packs/docker/pack.yaml</code>, <code>packs/docker/copier.yml</code>, <code>packs/docker/templates/...</code> - Test: <code>tests/packs/test_bundled_packs.py</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/packs/test_bundled_packs.py\nfrom pathlib import Path\nfrom pantsagon.application.pack_validation import validate_pack\n\n\ndef test_all_bundled_packs_validate():\n    packs_dir = Path(__file__).resolve().parents[2] / \"packs\"\n    for pack in [\"core\", \"python\", \"openapi\", \"docker\"]:\n        result = validate_pack(packs_dir / pack)\n        assert not [d for d in result.diagnostics if d.severity.value == \"error\"]\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/packs/test_bundled_packs.py -q</code> Expected: FAIL (missing packs)</p> <p>Step 3: Write minimal templates</p> <p>Create minimal <code>pack.yaml</code> + <code>copier.yml</code> and core skeleton templates for each pack. Example for core:</p> <pre><code># packs/core/pack.yaml\nid: pantsagon.core\nversion: 1.0.0\ndescription: Core monorepo skeleton\nvariables:\n  - name: repo_name\n    type: string\n</code></pre> <pre><code># packs/core/copier.yml\n_min_copier_version: \"9.0.0\"\n_subdirectory: \"templates\"\n_templates_suffix: \".jinja\"\nrepo_name:\n  type: str\n  default: \"repo\"\n</code></pre> <pre><code># packs/core/templates/pants.toml.jinja\n[GLOBAL]\npants_version = \"2.30.0\"\n</code></pre> <p>Repeat for python/openapi/docker with minimal placeholders.</p> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/packs/test_bundled_packs.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add packs tests/packs/test_bundled_packs.py\n\ngit commit -m \"feat: add bundled packs and pack tests\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-11-e2e-init-test-deterministic-mode","title":"Task 11: E2E init test (deterministic mode)","text":"<p>Files: - Test: <code>tests/e2e/test_init_e2e.py</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/e2e/test_init_e2e.py\nfrom pathlib import Path\nfrom pantsagon.entrypoints.cli import app\nfrom typer.testing import CliRunner\n\n\ndef test_init_generates_core_files(tmp_path, monkeypatch):\n    monkeypatch.setenv(\"PANTSAGON_DETERMINISTIC\", \"1\")\n    runner = CliRunner()\n    result = runner.invoke(app, [\"init\", str(tmp_path), \"--lang\", \"python\", \"--services\", \"monitors\", \"--feature\", \"openapi\", \"--feature\", \"docker\"])\n    assert result.exit_code == 0\n    assert (tmp_path / \"pants.toml\").exists()\n    assert (tmp_path / \".pantsagon.toml\").exists()\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/e2e/test_init_e2e.py -q</code> Expected: FAIL</p> <p>Step 3: Implement deterministic mode hook</p> <p>Add a global helper in <code>pantsagon/domain/determinism.py</code> to fix timestamps or skip them, and ensure CLI honors <code>PANTSAGON_DETERMINISTIC=1</code> by passing a deterministic flag into render/use-cases (even if no timestamps are emitted in v1).</p> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/e2e/test_init_e2e.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add tests/e2e/test_init_e2e.py pantsagon/domain/determinism.py\n\ngit commit -m \"test: add deterministic e2e init\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-cli-plan/#task-12-polish-cli-flags-augmented-coding-option","title":"Task 12: Polish CLI flags + augmented-coding option","text":"<p>Files: - Modify: <code>pantsagon/entrypoints/cli.py</code> - Modify: <code>pantsagon/application/init_repo.py</code> - Test: <code>tests/entrypoints/test_cli_augmented.py</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/entrypoints/test_cli_augmented.py\nfrom typer.testing import CliRunner\nfrom pantsagon.entrypoints.cli import app\n\n\ndef test_augmented_coding_creates_agents_file(tmp_path):\n    runner = CliRunner()\n    result = runner.invoke(app, [\"init\", str(tmp_path), \"--lang\", \"python\", \"--augmented-coding\", \"agents\"])\n    assert result.exit_code == 0\n    assert (tmp_path / \"AGENTS.md\").exists()\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/entrypoints/test_cli_augmented.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <p>Update <code>init_repo</code> to create AGENTS/CLAUDE/GEMINI file based on selection, and persist <code>selection.augmented_coding</code> in <code>.pantsagon.toml</code>.</p> <pre><code># pantsagon/application/init_repo.py (snippet)\naugmented = augmented_coding or \"none\"\nlock[\"selection\"][\"augmented_coding\"] = augmented\nif augmented == \"agents\":\n    (repo_path / \"AGENTS.md\").write_text(\"# AGENTS\\n\")\nelif augmented == \"claude\":\n    (repo_path / \"CLAUDE.md\").write_text(\"# CLAUDE\\n\")\nelif augmented == \"gemini\":\n    (repo_path / \"GEMINI.md\").write_text(\"# GEMINI\\n\")\n</code></pre> <p>Update CLI options:</p> <pre><code># pantsagon/entrypoints/cli.py (snippet)\naugmented_coding: str = typer.Option(\"none\", \"--augmented-coding\")\n</code></pre> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/entrypoints/test_cli_augmented.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/application/init_repo.py pantsagon/entrypoints/cli.py tests/entrypoints/test_cli_augmented.py\n\ngit commit -m \"feat: add augmented coding file option\"\n</code></pre> <p>Plan complete and saved to <code>docs/plans/2026-01-10-pantsagon-cli-plan.md</code>.</p> <p>Two execution options:</p> <ol> <li>Subagent-Driven (this session) \u2014 I dispatch a fresh subagent per task, review between tasks.</li> <li>Parallel Session (separate) \u2014 Open a new session with executing-plans and batch execution.</li> </ol> <p>Which approach would you like?</p>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/","title":"Pantsagon v1.0 Milestone Checklist","text":"<p>Goal: Reach a credible v1.0 release of Pantsagon with real pack rendering, complete CLI surface, and accurate docs.</p>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m0-documentation-licensing-baseline","title":"M0 \u2014 Documentation + Licensing Baseline","text":"<ul> <li>[ ] README reflects current state and planned features</li> <li>[ ] README explicitly states Apache License 2.0 (not MIT)</li> <li>[ ] <code>LICENSE</code> confirmed as Apache 2.0</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m1-pack-rendering-in-init-core-capability","title":"M1 \u2014 Pack Rendering in <code>init</code> (Core Capability)","text":"<ul> <li>[ ] Resolve pack selection: <code>core</code>, <code>python</code>, <code>openapi</code>, <code>docker</code></li> <li>[ ] Validate pack schema + manifest\u2194Copier variables</li> <li>[ ] Render packs into staging dir via Copier</li> <li>[ ] Atomic commit to repo</li> <li>[ ] <code>.pantsagon.toml</code> written into staged output</li> <li>[ ] E2E test verifies real skeleton files</li> <li>[ ] README updated to reflect rendering behavior</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m2-cli-surface-complete","title":"M2 \u2014 CLI Surface Complete","text":"<ul> <li>[ ] <code>pantsagon add service</code> implemented (naming rules, idempotent)</li> <li>[ ] <code>pantsagon validate</code> implemented (schema + lock drift + cross\u2011check)</li> <li>[ ] JSON output contract implemented</li> <li>[ ] Exit code precedence enforced</li> <li>[ ] README updated with full CLI usage</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m3-repo-lock-fidelity","title":"M3 \u2014 Repo Lock Fidelity","text":"<ul> <li>[ ] <code>.pantsagon.toml</code> split into <code>[tool]</code>, <code>[selection]</code>, <code>[resolved]</code>, <code>[settings]</code></li> <li>[ ] Persist pack refs (id/version/source + optional location/ref/digest)</li> <li>[ ] Persist resolved answers from Copier</li> <li>[ ] Validation detects lock drift</li> <li>[ ] README updated with lock structure</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m4-real-pack-content-hexagonal-skeleton","title":"M4 \u2014 Real Pack Content (Hexagonal Skeleton)","text":"<ul> <li>[ ] <code>core</code> pack: repo layout, CI scaffold, shared foundation/adapters</li> <li>[ ] <code>python</code> pack: hex layers + BUILD rules</li> <li>[ ] <code>openapi</code> pack: contract scaffolding + openapi targets</li> <li>[ ] <code>docker</code> pack: Dockerfile + <code>docker_image</code> target</li> <li>[ ] Pack tests cover schema + cross\u2011check + render smoke\u2011test</li> <li>[ ] README updated with example tree</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m5-policy-validation-hardening","title":"M5 \u2014 Policy + Validation Hardening","text":"<ul> <li>[ ] Naming rules: kebab\u2011case + reserved names</li> <li>[ ] Strictness tiers (<code>--strict</code> upgrades warnings \u2192 errors)</li> <li>[ ] Diagnostic codes + structured locations</li> <li>[ ] README updated with validation behavior</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-checklist/#m6-ci-release-readiness","title":"M6 \u2014 CI + Release Readiness","text":"<ul> <li>[ ] GitHub Actions runs pytest + pack validation</li> <li>[ ] Deterministic mode used in CI for reproducible tests</li> <li>[ ] Release checklist for v1.0.0</li> <li>[ ] README final pass</li> </ul>"},{"location":"plans/2026-01-10-pantsagon-v1-impl-plan/","title":"Pantsagon v1.0 Implementation Plan (Phase 1)","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Deliver M0 + M1 foundation: correct licensing/docs and real pack rendering in <code>init</code> with atomic staging.</p> <p>Architecture: Preserve hexagonal core. Add rendering workflow in application layer using existing ports/adapters. Update README to truthfully represent state.</p> <p>Tech Stack: Python 3.12, Typer, Copier, PyYAML, jsonschema, pytest.</p>"},{"location":"plans/2026-01-10-pantsagon-v1-impl-plan/#task-1-fix-readme-license-status-m0","title":"Task 1: Fix README license + status (M0)","text":"<p>Files: - Modify: <code>README.md</code> - Verify: <code>LICENSE</code></p> <p>Step 1: Write failing test (doc assertion)</p> <pre><code># tests/docs/test_readme_license.py\nfrom pathlib import Path\n\n\ndef test_readme_mentions_apache_license():\n    text = Path(\"README.md\").read_text().lower()\n    assert \"apache license 2.0\" in text\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/docs/test_readme_license.py -q</code> Expected: FAIL (license text missing)</p> <p>Step 3: Write minimal implementation</p> <p>Update <code>README.md</code>: - Add a \u201cLicense\u201d section that explicitly says Apache License 2.0. - Ensure status section reflects current capabilities (no misleading claims).</p> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/docs/test_readme_license.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add README.md tests/docs/test_readme_license.py\n\ngit commit -m \"docs: fix license statement in readme\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-v1-impl-plan/#task-2-init-renders-packs-into-staging-m1","title":"Task 2: <code>init</code> renders packs into staging (M1)","text":"<p>Files: - Modify: <code>pantsagon/application/init_repo.py</code> - Modify: <code>pantsagon/adapters/workspace/filesystem.py</code> - Create: <code>pantsagon/application/rendering.py</code> - Test: <code>tests/application/test_init_repo_renders.py</code> - Test: <code>tests/adapters/test_workspace_atomic.py</code></p> <p>Step 1: Write failing tests</p> <pre><code># tests/application/test_init_repo_renders.py\nfrom pathlib import Path\nfrom pantsagon.application.init_repo import init_repo\n\n\ndef test_init_repo_renders_core_pack(tmp_path):\n    result = init_repo(repo_path=tmp_path, languages=[\"python\"], services=[\"monitors\"], features=[\"openapi\", \"docker\"], renderer=\"copier\")\n    assert (tmp_path / \"pants.toml\").exists()\n    assert (tmp_path / \".pantsagon.toml\").exists()\n</code></pre> <pre><code># tests/adapters/test_workspace_atomic.py\nfrom pathlib import Path\nfrom pantsagon.adapters.workspace.filesystem import FilesystemWorkspace\n\n\ndef test_workspace_rollback_on_error(tmp_path, monkeypatch):\n    ws = FilesystemWorkspace(tmp_path)\n    stage = ws.begin_transaction()\n    (stage / \"file.txt\").write_text(\"data\")\n    monkeypatch.setattr(ws, \"_copy_file\", lambda *args, **kwargs: (_ for _ in ()).throw(RuntimeError(\"boom\")))\n    try:\n        ws.commit(stage)\n    except Exception:\n        pass\n    assert not (tmp_path / \"file.txt\").exists()\n</code></pre> <p>Step 2: Run tests to verify they fail</p> <p>Run: <code>pytest tests/application/test_init_repo_renders.py tests/adapters/test_workspace_atomic.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <ul> <li>Add <code>application/rendering.py</code> to:</li> <li>resolve pack paths (bundled only in v1)</li> <li>validate packs with <code>validate_pack</code></li> <li>call Copier renderer per pack into staging</li> <li>Update <code>FilesystemWorkspace</code>:</li> <li>add <code>_copy_file</code> helper for test injection</li> <li>ensure commit cleans stage and does not partially apply on error</li> <li>Update <code>init_repo</code> to:</li> <li>use staging dir</li> <li>render packs via new helper</li> <li>write <code>.pantsagon.toml</code> into staging</li> <li>commit atomically</li> <li>remove placeholder <code>pants.toml</code> write</li> </ul> <p>Step 4: Run tests to verify they pass</p> <p>Run: <code>pytest tests/application/test_init_repo_renders.py tests/adapters/test_workspace_atomic.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add pantsagon/application/init_repo.py pantsagon/application/rendering.py pantsagon/adapters/workspace/filesystem.py tests/application/test_init_repo_renders.py tests/adapters/test_workspace_atomic.py\n\ngit commit -m \"feat: render packs during init\"\n</code></pre>"},{"location":"plans/2026-01-10-pantsagon-v1-impl-plan/#task-3-readme-update-for-rendered-init-m1","title":"Task 3: README update for rendered init (M1)","text":"<p>Files: - Modify: <code>README.md</code></p> <p>Step 1: Write failing test</p> <pre><code># tests/docs/test_readme_init_rendering.py\nfrom pathlib import Path\n\n\ndef test_readme_mentions_rendered_init():\n    text = Path(\"README.md\").read_text().lower()\n    assert \"renders\" in text and \"init\" in text\n</code></pre> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>pytest tests/docs/test_readme_init_rendering.py -q</code> Expected: FAIL</p> <p>Step 3: Write minimal implementation</p> <p>Update README \u201cQuick start / Status\u201d to state that <code>init</code> renders packs into a real repo skeleton.</p> <p>Step 4: Run test to verify it passes</p> <p>Run: <code>pytest tests/docs/test_readme_init_rendering.py -q</code> Expected: PASS</p> <p>Step 5: Commit</p> <pre><code>git add README.md tests/docs/test_readme_init_rendering.py\n\ngit commit -m \"docs: update readme for rendered init\"\n</code></pre> <p>Plan complete and saved to <code>docs/plans/2026-01-10-pantsagon-v1-impl-plan.md</code>.</p> <p>Two execution options:</p> <ol> <li>Subagent-Driven (this session) \u2014 I dispatch a fresh subagent per task, review between tasks.</li> <li>Parallel Session (separate) \u2014 Open a new session with executing-plans and batch execution.</li> </ol> <p>Which approach would you like?</p>"},{"location":"plugin-authoring/","title":"Plugin authoring","text":"<p>Plugins provide adapter implementations for ports (future scope).</p> <p>In v1, plugins are not loaded, but the port contracts are designed for it.</p>"},{"location":"plugin-authoring/adapters/","title":"Adapters","text":"<p>Adapters implement ports. They should:</p> <ul> <li>raise typed AdapterError on IO/exec failures</li> <li>return Result/Diagnostics for expected validation outcomes</li> </ul>"},{"location":"plugin-authoring/discovery/","title":"Discovery (future)","text":"<p>Future plugins will be discovered via Python entry points, grouped by port:</p> <ul> <li>pantsagon.pack_catalog</li> <li>pantsagon.renderer</li> <li>pantsagon.workspace</li> <li>pantsagon.policy_engine</li> <li>pantsagon.command_runner</li> </ul>"},{"location":"plugin-authoring/ports/","title":"Ports","text":"<p>Core ports:</p> <ul> <li>PackCatalogPort</li> <li>RendererPort</li> <li>WorkspacePort</li> <li>PolicyEnginePort</li> <li>CommandPort</li> </ul> <p>Ports accept and return domain objects and must not leak implementation details.</p>"},{"location":"reference/diagnostic-codes/","title":"Diagnostic codes","text":"<p>Generated file. Do not edit directly. Run: <code>python scripts/generate_diagnostic_codes.py</code></p>"},{"location":"reference/diagnostic-codes/#diagnostic-codes","title":"Diagnostic codes","text":"<p>This page is generated from <code>pantsagon/diagnostics/codes.yaml</code>.</p> Code Severity Rule Message Hint <code>COPIER_DEFAULT_MISMATCH</code> <code>warn</code> <code>pack.variables.default_mismatch</code> Copier default does not match pack.yaml default. Align defaults, or run in strict mode to fail builds. <code>COPIER_UNDECLARED_VARIABLE</code> <code>error</code> <code>pack.variables.copier_undeclared</code> Copier defines a variable that is not declared in pack.yaml. Declare it in pack.yaml.variables or remove it from copier.yml. <code>PACK_MISSING_REQUIRED</code> <code>error</code> <code>pack.requires.packs</code> Pack is missing required dependency packs. Add the required pack or choose a compatible feature set. <code>PACK_NOT_FOUND</code> <code>error</code> <code>pack.catalog.fetch</code> Pack could not be found. Check pack id/version and configured pack sources."},{"location":"reference/pack.schema.v1/","title":"pack.schema.v1","text":"<p>Generated file. Do not edit directly. Run: <code>python scripts/generate_schema_docs.py</code></p>"},{"location":"reference/pack.schema.v1/#pantsagon-pack-manifest-v1","title":"Pantsagon Pack Manifest (v1)","text":"<p>Tool-agnostic manifest describing a Pantsagon pack: identity, compatibility, features, and variables.</p> <ul> <li>$id: <code>https://pantsagon.dev/schemas/pack.schema.v1.json</code></li> <li>$schema: <code>https://json-schema.org/draft/2020-12/schema</code></li> </ul>"},{"location":"reference/pack.schema.v1/#properties","title":"Properties","text":"Name Type Required Description <code>compatibility</code> <code>object</code> yes <code>description</code> <code>string</code> no Human-readable description of the pack. <code>id</code> <code>string</code> yes Globally unique pack identifier (e.g. pantsagon.python). <code>provides</code> <code>object</code> no <code>requires</code> <code>object</code> no <code>schema_version</code> <code>integer</code> no Schema version for this manifest. <code>variables</code> <code>array</code> no Variables required or accepted by this pack. <code>version</code> <code>string</code> yes SemVer version of the pack."},{"location":"reference/pack.schema.v1/#raw-json","title":"Raw JSON","text":"<pre><code>{\n  \"$id\": \"https://pantsagon.dev/schemas/pack.schema.v1.json\",\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"additionalProperties\": false,\n  \"description\": \"Tool-agnostic manifest describing a Pantsagon pack: identity, compatibility, features, and variables.\",\n  \"properties\": {\n    \"compatibility\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"languages\": {\n          \"additionalProperties\": {\n            \"description\": \"Supported version range for a language (e.g. python: \\\"&gt;=3.12,&lt;3.15\\\").\",\n            \"type\": \"string\"\n          },\n          \"type\": \"object\"\n        },\n        \"pants\": {\n          \"description\": \"Supported Pants version range (PEP 440 / semver-style range).\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"pants\"\n      ],\n      \"type\": \"object\"\n    },\n    \"description\": {\n      \"description\": \"Human-readable description of the pack.\",\n      \"type\": \"string\"\n    },\n    \"id\": {\n      \"description\": \"Globally unique pack identifier (e.g. pantsagon.python).\",\n      \"pattern\": \"^[a-z0-9_.-]+$\",\n      \"type\": \"string\"\n    },\n    \"provides\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"features\": {\n          \"description\": \"Feature flags provided by this pack (e.g. openapi, docker).\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"service_templates\": {\n          \"description\": \"Service template capabilities exposed by this pack.\",\n          \"items\": {\n            \"additionalProperties\": false,\n            \"properties\": {\n              \"kind\": {\n                \"description\": \"Template kind.\",\n                \"enum\": [\n                  \"service\"\n                ],\n                \"type\": \"string\"\n              },\n              \"language\": {\n                \"description\": \"Language supported by this template.\",\n                \"type\": \"string\"\n              },\n              \"layout\": {\n                \"description\": \"Declared layout (e.g. hexagonal).\",\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"kind\",\n              \"language\"\n            ],\n            \"type\": \"object\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"requires\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"packs\": {\n          \"description\": \"Other packs that must be present for this pack to be applied.\",\n          \"items\": {\n            \"pattern\": \"^[a-z0-9_.-]+$\",\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"schema_version\": {\n      \"const\": 1,\n      \"description\": \"Schema version for this manifest.\",\n      \"type\": \"integer\"\n    },\n    \"variables\": {\n      \"description\": \"Variables required or accepted by this pack.\",\n      \"items\": {\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"default\": {\n            \"description\": \"Default value if not provided.\"\n          },\n          \"enum\": {\n            \"description\": \"Allowed values when type is enum.\",\n            \"items\": {\n              \"type\": \"string\"\n            },\n            \"type\": \"array\"\n          },\n          \"name\": {\n            \"description\": \"Variable name.\",\n            \"pattern\": \"^[a-zA-Z_][a-zA-Z0-9_]*$\",\n            \"type\": \"string\"\n          },\n          \"required\": {\n            \"default\": false,\n            \"description\": \"Whether the variable is required.\",\n            \"type\": \"boolean\"\n          },\n          \"type\": {\n            \"description\": \"Variable type.\",\n            \"enum\": [\n              \"string\",\n              \"int\",\n              \"bool\",\n              \"enum\"\n            ],\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"type\"\n        ],\n        \"type\": \"object\"\n      },\n      \"type\": \"array\"\n    },\n    \"version\": {\n      \"description\": \"SemVer version of the pack.\",\n      \"pattern\": \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"id\",\n    \"version\",\n    \"compatibility\"\n  ],\n  \"title\": \"Pantsagon Pack Manifest (v1)\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"reference/repo-lock.schema.v1/","title":"repo lock schema","text":"<p>Generated file. Do not edit directly. Run: <code>python scripts/generate_schema_docs.py</code></p>"},{"location":"reference/repo-lock.schema.v1/#pantsagon-repo-lock-pantsagontoml-v1","title":"Pantsagon Repo Lock (.pantsagon.toml) (v1)","text":"<p>Single source of truth for a Pantsagon-generated repository.</p> <ul> <li>$id: <code>https://pantsagon.dev/schemas/repo-lock.schema.v1.json</code></li> <li>$schema: <code>https://json-schema.org/draft/2020-12/schema</code></li> </ul>"},{"location":"reference/repo-lock.schema.v1/#properties","title":"Properties","text":"Name Type Required Description <code>resolved</code> <code>object</code> yes <code>selection</code> <code>object</code> no <code>settings</code> <code>object</code> no <code>tool</code> <code>object</code> yes"},{"location":"reference/repo-lock.schema.v1/#raw-json","title":"Raw JSON","text":"<pre><code>{\n  \"$id\": \"https://pantsagon.dev/schemas/repo-lock.schema.v1.json\",\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"additionalProperties\": false,\n  \"description\": \"Single source of truth for a Pantsagon-generated repository.\",\n  \"properties\": {\n    \"resolved\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"answers\": {\n          \"additionalProperties\": true,\n          \"description\": \"Resolved variable answers passed to the renderer.\",\n          \"type\": \"object\"\n        },\n        \"packs\": {\n          \"items\": {\n            \"additionalProperties\": false,\n            \"properties\": {\n              \"id\": {\n                \"type\": \"string\"\n              },\n              \"location\": {\n                \"description\": \"Filesystem path or URL, depending on source.\",\n                \"type\": \"string\"\n              },\n              \"ref\": {\n                \"description\": \"Git ref, commit, or registry digest.\",\n                \"type\": \"string\"\n              },\n              \"source\": {\n                \"enum\": [\n                  \"bundled\",\n                  \"local\",\n                  \"git\",\n                  \"registry\"\n                ],\n                \"type\": \"string\"\n              },\n              \"version\": {\n                \"type\": \"string\"\n              }\n            },\n            \"required\": [\n              \"id\",\n              \"version\",\n              \"source\"\n            ],\n            \"type\": \"object\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"required\": [\n        \"packs\"\n      ],\n      \"type\": \"object\"\n    },\n    \"selection\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"features\": {\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"languages\": {\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        },\n        \"services\": {\n          \"items\": {\n            \"pattern\": \"^[a-z][a-z0-9-]*$\",\n            \"type\": \"string\"\n          },\n          \"type\": \"array\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"settings\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"allow_hooks\": {\n          \"default\": false,\n          \"description\": \"Whether pack hooks are allowed to execute.\",\n          \"type\": \"boolean\"\n        },\n        \"renderer\": {\n          \"default\": \"copier\",\n          \"description\": \"Renderer adapter to use.\",\n          \"type\": \"string\"\n        },\n        \"strict\": {\n          \"default\": false,\n          \"description\": \"Whether strict mode is enabled.\",\n          \"type\": \"boolean\"\n        },\n        \"strict_manifest\": {\n          \"default\": true,\n          \"description\": \"Whether manifest/Copier mismatches are fatal.\",\n          \"type\": \"boolean\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"tool\": {\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"name\": {\n          \"const\": \"pantsagon\",\n          \"type\": \"string\"\n        },\n        \"version\": {\n          \"description\": \"Pantsagon tool version used to generate or update this repo.\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"version\"\n      ],\n      \"type\": \"object\"\n    }\n  },\n  \"required\": [\n    \"tool\",\n    \"resolved\"\n  ],\n  \"title\": \"Pantsagon Repo Lock (.pantsagon.toml) (v1)\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"reference/result.schema.v1/","title":"result schema","text":"<p>Generated file. Do not edit directly. Run: <code>python scripts/generate_schema_docs.py</code></p>"},{"location":"reference/result.schema.v1/#pantsagon-result-v1","title":"Pantsagon Result (v1)","text":"<p>Structured output returned by Pantsagon commands for humans and machines.</p> <ul> <li>$id: <code>https://pantsagon.dev/schemas/result.schema.v1.json</code></li> <li>$schema: <code>https://json-schema.org/draft/2020-12/schema</code></li> </ul>"},{"location":"reference/result.schema.v1/#properties","title":"Properties","text":"Name Type Required Description <code>artifacts</code> <code>array</code> no Artifacts produced by the command (paths, packs, commands). <code>diagnostics</code> <code>array</code> yes Structured diagnostics emitted during execution. <code>exit_code</code> <code>integer</code> yes Process exit code. <code>result_schema_version</code> <code>integer</code> yes Schema version for the Result object."},{"location":"reference/result.schema.v1/#raw-json","title":"Raw JSON","text":"<pre><code>{\n  \"$id\": \"https://pantsagon.dev/schemas/result.schema.v1.json\",\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"additionalProperties\": false,\n  \"description\": \"Structured output returned by Pantsagon commands for humans and machines.\",\n  \"properties\": {\n    \"artifacts\": {\n      \"description\": \"Artifacts produced by the command (paths, packs, commands).\",\n      \"items\": {\n        \"additionalProperties\": true,\n        \"type\": \"object\"\n      },\n      \"type\": \"array\"\n    },\n    \"diagnostics\": {\n      \"description\": \"Structured diagnostics emitted during execution.\",\n      \"items\": {\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"code\": {\n            \"description\": \"Short, stable diagnostic code (e.g. PACK_NOT_FOUND).\",\n            \"type\": \"string\"\n          },\n          \"details\": {\n            \"additionalProperties\": true,\n            \"description\": \"Optional machine-readable details.\",\n            \"type\": \"object\"\n          },\n          \"hint\": {\n            \"description\": \"Optional remediation hint.\",\n            \"type\": \"string\"\n          },\n          \"id\": {\n            \"description\": \"Stable or deterministic diagnostic identifier.\",\n            \"type\": \"string\"\n          },\n          \"location\": {\n            \"additionalProperties\": true,\n            \"description\": \"Optional structured location of the diagnostic.\",\n            \"type\": \"object\"\n          },\n          \"message\": {\n            \"type\": \"string\"\n          },\n          \"rule\": {\n            \"description\": \"Rule identifier or namespace (e.g. pack.requires.packs).\",\n            \"type\": \"string\"\n          },\n          \"severity\": {\n            \"enum\": [\n              \"error\",\n              \"warn\",\n              \"info\"\n            ],\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"code\",\n          \"rule\",\n          \"severity\",\n          \"message\"\n        ],\n        \"type\": \"object\"\n      },\n      \"type\": \"array\"\n    },\n    \"exit_code\": {\n      \"description\": \"Process exit code.\",\n      \"enum\": [\n        0,\n        2,\n        3,\n        4\n      ],\n      \"type\": \"integer\"\n    },\n    \"result_schema_version\": {\n      \"const\": 1,\n      \"description\": \"Schema version for the Result object.\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"result_schema_version\",\n    \"exit_code\",\n    \"diagnostics\"\n  ],\n  \"title\": \"Pantsagon Result (v1)\",\n  \"type\": \"object\"\n}\n</code></pre>"}]}